{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction "},"Linux相关/":{"url":"Linux相关/","title":"Linux相关","keywords":"","body":"Introduction "},"Linux相关/make工具的使用.html":{"url":"Linux相关/make工具的使用.html","title":"Make工具的使用","keywords":"","body":"Linux下C语言简单实现cat、ls、cd命令 由于Linux命令一般都含有很多可选参数，可以完成很多操作，这里仅实现其最基本的不加参数功能 cat命令的简单实现 //mycat.c #include int main(int argc, char *argv[]) { FILE *fp = fopen(argv[1], \"r\"); // 以只读方式打开文件，argv[1]是输入的要显示的文件路径名 int read_ret; if(argc ls命令的简单实现 //myls.c #include #include #include int main(int argc, char* argv[]) { DIR *dp=NULL; struct dirent * dt=NULL; dp=opendir(\"./\"); if(dp==NULL) { perror(\"opendir err\"); return -1; } while(1) { dt = readdir(dp); if(dt==NULL) { break; } if(dt->d_name[0] != '.') printf(\"%s\\n\", dt->d_name); } closedir(dp); return 0; } cd命令的简单实现 //mycd.c #include #include int main()//正确的 { char s[]=\"test\";//当前目录下面有名为test的文件夹 chdir (s); char xxx[1024];//获取当前目录并打印 getcwd(xxx,1024); printf(\"The current directory is : %s\\n\",xxx); } chdir函数——change working directory #include int chdir(const char *path); 需要注意的是，chdir并不是直接把终端当前的目录切换，而是在编写的程序(mycd.c)进程中切换当前工作目录 关于chdir更详细的信息可在Linux系统终端输入命令man chdir查看 make工具的简单使用 编写makefile文件，以刚才编写的mycd.c为例 #makefile mycd: mycd.o gcc -o mycd mycd.o clean: rm -f *.o 执行make命令 生成了mycd.o文件以及可执行文件mycd 执行make clean可以删除mycd.o文件 测试可执行文件 注意：终端这里的路径是不会变的，不是程序写错了哦！ "},"springboot/":{"url":"springboot/","title":"Springboot","keywords":"","body":"Introduction "},"springboot/springboot一些遇到的问题.html":{"url":"springboot/springboot一些遇到的问题.html","title":"Springboot一些遇到的问题","keywords":"","body":"springboot启动白页(Whitelable Error Page)的问题 使用SpringBoot写HelloWorld，当配置好启动类后，再创建新的controller或其它类，启动项目后访问对应的映射名，页面显示： Whitelabel Error Page This application has no explicit mapping for /error, so you are seeing this as a fallback. 映射未找到，出现这个异常说明了跳转页面的url无对应的值. 解决： 排查过程： 　　1、先确定URL是否正确（正确无误）； 　　2、由于之前自己写过，并且成功访问，但是这次没有成功，所以进行比较，发现启动类的位置不同，上网找了找资料，发现SpringBoot默认扫描的范围为本包及子包： 　　　　进入@SpringBootApplication的源码： 　　　　而@ComponentScan的默认扫描范围为本包及子包； 所以只需将访问的Controller类放到启动类的同级或子级的路径下，就可以了； 或者在启动类上指定@ComponentScan的范围就OK了！ 配置mybatis The server time zone value '�й���׼ʱ��' is unrecognized or represents more than one time zone 解决方法是在mysql的url参数后面加上参数：“?serverTimezone=UTC” spring: datasource: url: jdbc:mysql://localhost:3306/springboot?characterEncoding=utf-8&serverTimezone=UTC username: root password: 991568 driver-class-name: com.mysql.cj.jdbc.Driver 但是之后数据库时间差了八小时 将UTC改成Asia/Shanghai url: jdbc:mysql://localhost:3306/springboot?characterEncoding=utf-8&serverTimezone=Asia/Shanghai UTC代表全球标准时间，我国时间要领先8小时 配置通用Mapper(代码生成器) At least one base package must be specified 没有扫描到mapper包 方式一： 在Mapper接口上添加@Mapper注解 方式二： 在Application.java启动类上添加@MapperScan()注解扫描所有Mapper接口。注意这里的@MapperScan注解来自tk.mybatis.spring.annotation.MapperScan，用spring的会报错。 不知道为什么，方法一我没成功 方法二 @MapperScan(\"top.yll.mapper\") 解决跨域问题 添加@CrossOrigin注解 加载yml失败 删除带所有带中文的注释 controller调用service报错空指针异常 我的错误原因： controller层中的service没有注入 解决方法：加注解（@Resource @Autowired） 其他原因 调用controller报空指针有两种情况： service 或者mapper 没有加载到spring容器中 ，引用时候肯定报空指针 service加载到spring容器中了， 但是controller中定义的方法为private，私有方法被接口访问时候，因为private作用域的问题，无法获取该方法，报空指针 service层没有使用@Service修饰(接口不需要加，在impl中加) 部署相关 jps #查看Java进程 kill -9 #杀死进程 taskkill /pid #Windows命令行 nohup java -jar xxx.jar #退出命令行后仍然运行 数据库第三次实验 前端传日期失败 input中使用text不用datetimelocal 日期时区不对导致操作数据库失败 date.setHours(date.getHours()-14);//获取日期时更改相差的时间 //另 Date date1 = new Date(2020-1900, Calendar.JULY,10,10,11,11);//如果不-2020，年份为3920 Date date2 = new Date(2020-1900, Calendar.JULY,10,10,11,11); System.out.println(date1==date2);//false System.out.println(date1.equals(date2));//true 通过Session和th:if隐藏一些内容 @RequestMapping(\"/login\") public String login(User user, Model model, HttpSession session) { if (checkUser(user)) { session.setAttribute(\"loginUser\", user.getUsername()); session.setAttribute(\"userType\", user.getUserType()); return \"redirect:/main.html\"; } else { model.addAttribute(\"msg\", \"用户名或密码错误\"); model.addAttribute(\"type\", user.getUserType()); return \"login\"; } } 操作 Thymeleaf传两个参数，Controller接收 编辑 删除 @GetMapping(\"/toUpdatePage/{flight_id}/{date}\") public String toUpdatePage(@PathVariable(\"flight_id\") String flight_id, @PathVariable(\"date\") Date date) { } @GetMapping(\"/deleteFlight/{flight_id}/{date}\") public String deleteFlight(@PathVariable(\"flight_id\") String flight_id, @PathVariable(\"date\") Date date ){ } "},"vue/":{"url":"vue/","title":"Vue","keywords":"","body":"Introduction "},"vue/vue+ssm跨域问题.html":{"url":"vue/vue+ssm跨域问题.html","title":"Vue+Ssm跨域问题","keywords":"","body":"问题 vue登陆请求http://127.0.0.1:8081/yangllong_ssm/login.do @RestController public class VueController { @RequestMapping(\"/login\") public String login( @RequestParam(value=\"username\",required = false) String username, @RequestParam(value=\"password\",required = false) String password, Model model ){ System.out.println(\"username:\"+username+\"password:\"+password); if (username.equals(\"admin\") && password.equals(\"123\")){ System.out.println(\"登陆成功\"); return \"index\";}else{ model.addAttribute(\"error\",\"用户登陆失败，错误信息：\"); return \"login\"; } } } methods: { submitForm(login) { this.$refs[login].validate(valid => { if (valid) { //提交表单 this.$http .post(\"http://127.0.0.1:8081/yangllong_ssm/login.do\", { username: this.login.username, password: this.login.password }) .then(result => { console.log(result); if (result.bodyText === \"index\") { this.$router.push({ path: \"home\" }); //跳转到home组件中 } else { console.log(\"登录失败\"); return false; } }); } else { console.log(\"error submit!!\"); return false; } }); } } 我之前写的@Controller，返回的一直是jsp页面，报错404 要用@RestController注解！ 解决跨域问题 "},"vue/vue-cli3.html":{"url":"vue/vue-cli3.html","title":"Vue Cli3","keywords":"","body":"vue-cli3 创建项目 vue create test //test是项目名 选择Mannally，回车 选择basel和router(空格选择)，回车确认 使用history mode 选择packa.json 后面直接回车等待项目创建完成 npm run serve//启动项目 安装axios cnpm i axios -S 在main.js文件中添加以下代码 //导入 import axios from 'axios' //全局注册 Vue.prototype.$http=axios; "},"vue/安装vue.html":{"url":"vue/安装vue.html","title":"安装Vue","keywords":"","body":"初识vue 安装vue 采用npm方法安装 先要安装node.js环境（npm包管理器） vue-cli脚手架构建工具 cnpm npm淘宝镜像 我之前已经安装好了npm与cnpm淘宝镜像 下面直接安装vue-cli脚手架 命令行执行 npm install -g vue-cli 创建一个vue文件夹 cd进入此文件夹 vue init webpack firstApp 解释一下这个命令，这个命令的意思是初始化一个项目，其中webpack是构建工具，也就是整个项目是基于webpack的。其中firstApp是整个项目文件夹的名称，这个文件夹会自动生成在你指定的目录中 cd firstApp cnpm install 运行初始化命令的时候会让用户输入几个基本的配置选项，如项目名称、项目描述、作者信息，对于有些不明白或者不想填的信息可以一直按回车去填写就好了，等待一会，就会显示创建项目创建成功 如图 cd firstApp npm run dev 运行项目 "},"其他/":{"url":"其他/","title":"其他","keywords":"","body":"Introduction "},"其他/分布式系统.html":{"url":"其他/分布式系统.html","title":"分布式系统","keywords":"","body":"分布式系统概念 单个应用程序需要处理的数据，服务量太大，分散在不同的计算机中。 让用户认为是在一个计算机系统中进行的 发展演变 RPC 通讯效率 序列化与反序列化效率 对象序列化？？ dubbo "},"其他/图解http.html":{"url":"其他/图解http.html","title":"图解Http","keywords":"","body":"TCP/IP协议族 为了实现计算机设备间的通信，双方必须规定好相同的规则，这种规则就叫做协议。 TCP/IP是互联网相关的各类协议族的总称，HTTP属于它内部的一个子集 "},"其他/消息队列.html":{"url":"其他/消息队列.html","title":"消息队列","keywords":"","body":"消息队列常见使用场景，核心的有 3 个：解耦、异步、削峰。 缺点： 系统可用性降低 系统复杂度提高 一致性问题 如何保证高可用性 RabbitMQ 是基于主从（非分布式）做高可用性的， 镜像集群模式（高可用性） "},"其他/爬虫.html":{"url":"其他/爬虫.html","title":"爬虫","keywords":"","body":"https://blog.csdn.net/fengsigaoju/article/details/48553753 URL的格式由三部分组成： ①第一部分是协议(或称为服务方式)。 ②第二部分是存有该资源的主机IP地址(有时也包括端口号)。 ③第三部分是主机资源的具体地址，如目录和文件名等。 第一部分和第二部分用“://”符号隔开， 第二部分和第三部分用“/”符号隔开。 第一部分和第二部分是不可缺少的，第三部分有时可以省略。 文件的URL 例：file://ftp.yoyodyne.com/pub/files/foobar.txt 上面这个URL代表存放在主机ftp.yoyodyne.com上的pub/files/目录下的一个文件，文件名是foobar.txt。 爬虫最主要的处理对象就是URL，它根据URL地址取得所需要的文件内容，然后对它 进行进一步的处理。 "},"刷题/":{"url":"刷题/","title":"刷题","keywords":"","body":"Introduction "},"刷题/NOJ.html":{"url":"刷题/NOJ.html","title":"NOJ","keywords":"","body":"NO.2 求最值(多组输入) Description: 给定N个整数（1 Input: 多组数据，第一行为一个整数N，第二行为N个不超过100的正整数，用空格隔开。 Output: 对每组数据输出一行，包含两个整数，用一个空格隔开，分别表示N个数中的最大值和最小值 Sample Input: 5 4 6 7 3 1 4 4 3 5 1 Sample Output: 7 1 5 1 import java.util.Scanner; public class Main { public static void main(String[] args){ Scanner s = new Scanner(System.in); while (s.hasNextInt()){//多组输入 int n = s.nextInt(); int max = 0; int min = 101; while(n-->0){ int num = s.nextInt(); if(num>max)max=num; if(num NOJ1005 多项式加法 错误代码 import java.util.Scanner; public class Main { public static void main(String[] args){ Scanner s = new Scanner(System.in); int k,n; k = s.nextInt(); n =s .nextInt(); if (k0) System.out.print(\"+\"); if (k==0&&n==-1) System.out.println(); }while (k!=0&&n!=-1&&s.hasNextInt()); } } NOJ1015最大公约数最小公倍数 import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner s =new Scanner(System.in); int a =s.nextInt(); int b =s.nextInt(); int gcd = gcd(a,b); int gcb = a*b/gcd;//最小公倍数为a*b除以最大公约数 System.out.println(gcd+\" \"+gcb); } static public int gcd(int a, int b) { if (a == 0) return a; if (b == 0) return b; if (a > b) { int swap = a; a = b; b = swap; } while (a>0){ int c = b%a; b=a; a=c; } return b; } } "},"刷题/leetcode/":{"url":"刷题/leetcode/","title":"Leetcode","keywords":"","body":"Introduction "},"刷题/leetcode/107简单题.html":{"url":"刷题/leetcode/107简单题.html","title":"107简单题","keywords":"","body":"10.7简单题 1.IP地址无效化 所谓无效化 IP 地址，其实就是用 \"[.]\" 代替了每个 \".\"。 示例 1： 输入：address = \"1.1.1.1\" 输出：\"1[.]1[.]1[.]1\" 直接使用了replace函数 class Solution { public String defangIPaddr(String address) { return address.replace(\".\",\"[.]\"); } } 2.猜数字 应该是最简单的题了吧 class Solution { public int game(int[] guess, int[] answer) { int count = 0; for(int i = 0; i 3.删除链表中的节点 示例 输入: head = [4,5,1,9], node = 5 输出: [4,1,9] 解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9. /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public void deleteNode(ListNode node) { node.val=node.next.val; node.next=node.next.next; } } 是我想多了，不需要用到前一个节点。直接把当前节点的值和“指针”都改为下一个就好了 4.二叉搜索树的范围和 给定二叉搜索树的根结点 root，返回 L 和 R（含）之间的所有结点的值的和。 二叉搜索树保证具有唯一的值。 示例 输入：root = [10,5,15,3,7,null,18], L = 7, R = 15 输出：32 递归实现深度优先搜索 /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { int result; public int rangeSumBST(TreeNode root, int L, int R) { result=0; dfs(root,L,R); return result; } public void dfs(TreeNode node, int L, int R){ if(node!=null){ if(node.val>=L&&node.valL) dfs(node.left,L, R); } } } "},"刷题/leetcode/2两数相加.html":{"url":"刷题/leetcode/2两数相加.html","title":"2两数相加","keywords":"","body":"给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例： 输入：(2 -> 4 -> 3) + (5 -> 6 -> 4) 输出：7 -> 0 -> 8 原因：342 + 465 = 807 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode pre = new ListNode(0); ListNode cur = pre; int carry = 0; while(l1 != null || l2 != null) { int x = l1 == null ? 0 : l1.val; int y = l2 == null ? 0 : l2.val; int sum = x + y + carry; carry = sum / 10; sum = sum % 10; cur.next = new ListNode(sum); cur = cur.next; if(l1 != null) l1 = l1.next; if(l2 != null) l2 = l2.next; } if(carry == 1) { cur.next = new ListNode(carry); } return pre.next; } } 将两个链表看成是相同长度的进行遍历，如果一个链表较短则在前面补 00，比如 987 + 23 = 987 + 023 = 1010 每一位计算的同时需要考虑上一位的进位问题，而当前位计算结束后同样需要更新进位值 如果两个链表全部遍历完毕后，进位值为 1，则在新链表最前方添加节点 1 小技巧：对于链表问题，返回结果为头结点时，通常需要先初始化一个预先指针 pre，该指针的下一个节点指向真正的头结点head。使用预先指针的目的在于链表初始化时无可用节点值，而且链表构造过程需要指针移动，进而会导致头指针丢失，无法返回结果。 "},"刷题/leetcode/3无重复子串的最大长度.html":{"url":"刷题/leetcode/3无重复子串的最大长度.html","title":"3无重复子串的最大长度","keywords":"","body":"给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 输入: \"abcabcbb\" 输出: 3 解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。 示例 2: 输入: \"bbbbb\" 输出: 1 解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。 示例 3: 输入: \"pwwkew\" 输出: 3 解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。 标签：滑动窗口 暴力解法时间复杂度较高，会达到 O(n^2^)，故而采取滑动窗口的方法降低时间复杂度 定义一个 map 数据结构存储 (k, v)，其中 key 值为字符，value 值为字符位置 +1，加 1 表示从字符位置后一个才开始不重复 我们定义不重复子串的开始位置为 start，结束位置为 end 随着 end 不断遍历向后，会遇到与 [start, end] 区间内字符相同的情况，此时将字符作为 key 值，获取其 value 值，并更新 start，此时 [start, end] 区间内不存在重复字符 无论是否更新 start，都会更新其 map 数据结构和结果 ans。 时间复杂度：O(n)O(n) class Solution { public int lengthOfLongestSubstring(String s) { int n = s.length(), ans = 0; Map map = new HashMap<>(); for (int end = 0, start = 0; end class Solution { public int lengthOfLongestSubstring(String s) { if (s.length()==0) return 0; HashMap map = new HashMap(); int max = 0; int left = 0; for(int i = 0; i "},"刷题/扇贝杯csdn.html":{"url":"刷题/扇贝杯csdn.html","title":"扇贝杯Csdn","keywords":"","body":"A. UCU与SadBB的故事 在很久很久以前，大概也就是3年前，SadBB觉得他的ID过于愚蠢，所以决定换一个ID。于是一个奇怪的ID：UCU，横空出世。 大家觉得UCU一定有着奇怪的含义，比如说可能是一位美丽可爱的小姐姐的代号。 基于这样的猜测，某侦探开始了他的破案之旅，他认为UCU一定代表着，这个小姐姐的名字的第一个字和最后一个字的首字母是一样的，且第二个字的首字母为C。 他收集了SadBB认识的可爱的小姐姐的名字，筛选出了其中三个字的名字，并将她们名字转换成了拼音，眼看真相就要水落石出，来自东方的一股神秘力量将他封印了起来。 现在你拿到了这份名单（所有名字都被转换为拼音全拼了），你能帮忙寻找出这谜之可能存在的小姐姐吗？（本故事纯属虚构） 输入： 第1行为一个整数n，1 第2到n+1行，每行由三个拼音单词组成，拼音单词之间用空格隔开。 输出： 每行输出一个满足条件的名字的拼音，每个名字的三个拼音之间用空格隔开，名字的输出顺序应与输入顺序一致。 样例输入： 4 yu bu yu jiang chun ji guan jin chu li chen liang 样例输出： jiang chun ji li chen liang import java.util.ArrayList; import java.util.List; import java.util.Scanner; public class Test { public static void main(String[] args) { int n; Scanner scanner = new Scanner(System.in); n=scanner.nextInt(); List names = new ArrayList<>(); scanner.nextLine();//跳过上面的换行 while (n-->0){ String name = scanner.nextLine(); names.add(name); } for (String na:names) { String[] naSplit = na.split(\" \"); if (naSplit[0].charAt(0)==naSplit[2].charAt(0)&&naSplit[1].charAt(0)=='c') System.out.println(na); } } } "},"刷题/排序算法.html":{"url":"刷题/排序算法.html","title":"排序算法","keywords":"","body":"快速排序法 /** * 快速排序 * * @param a 待排序数组 * @param firstIndex 数组最左边元素索引 * @param lastIndex 数组最右边元素索引 */ public static void quickSort(int[] a, int firstIndex, int lastIndex) { int start = firstIndex; int end = lastIndex; int key = a[firstIndex]; while (end > start) {//这里不要写成大于等于，否则会出现死循环 //从后往前比较 while (end > start && a[end] >= key) {//这里的大于和大于等于也不能加等号和删等号，否则会出现越界（前面加等号）和死循环（后面删等号），下面的while循环同理 //如果没有比关键值小的，比较下一个，直到有比关键值小的交换位置，然后又从前往后比较 end--; } if (a[end] start && a[start] key) { int temp = a[start]; a[start] = a[end]; a[end] = temp; } //此时第一次循环比较结束，关键值的位置已经确定了。左边的值都比关键值小，右边的值都比关键值大，但是两边的顺序还是可能是不一样的，进行下面的递归调用 } //递归 这里也不能加等号，会发生StackOverflowError if (start > firstIndex) quickSort(a, firstIndex, start - 1); if (end 直接插入排序法 /** * 直接插入排序 * 一个n-1次的for循环为需要插入的次数，一个while循环是将要插入的数与前面的数比大小 * * @param a 待排序数组 */ private static void insertSort(int[] a) { if (a.length == 0) return; for (int i = 1; i 0 && a[j - 1] > insertNum) {//从后往前一个一个比较，把比insertNum大的往后移一位 a[j] = a[j - 1];//比insertNum大的后移 j--;//再和前面一个数比较大小,前面没有数了(此时j=0)就跳出while循环 } a[j] = insertNum;//将要插入的数放在要插入的位置 } } 希尔排序 /** * 希尔排序 * * @param a 待排序数组 */ private static void shellSort(int[] a) { if (a.length == 0) return; int len = a.length; while (len != 0) { len = len / 2; for (int g = 0; g = 0 && a[j] > temp; j -= len) { a[j + len] = a[j]; } a[j + len] = temp; } } } } "},"刷题/蓝桥杯.html":{"url":"刷题/蓝桥杯.html","title":"蓝桥杯","keywords":"","body":"一个字符串的非空子串是指字符串中长度至少为 1 的连续的一段字符组成 的串。例如，字符串 aaab 有非空子串 a, b, aa, ab, aaa, aab, aaab，一共 7 个。 注意在计算时，只算本质不同的串的个数。 请问，字符串 0100110001010001 有多少个不同的非空子串？ import java.util.*; public class Test { public static void main(String[] args) { String target = \"0100110001010001\"; Set sub = new HashSet<>(); for (int step = 0; step "},"刷题/蓝桥杯热身赛.html":{"url":"刷题/蓝桥杯热身赛.html","title":"蓝桥杯热身赛","keywords":"","body":"G Description: 陶陶家的院子里有一棵苹果树，每到秋天树上就会结出10个苹果。苹果成熟的时候，陶陶就会跑去摘苹果。陶陶有个30厘米高的板凳，当她不能直接用手摘到苹果的时候，就会踩到板凳上再试试。 现在已知10个苹果到地面的高度，以及陶陶把手伸直的时候能够达到的最大高度，请帮陶陶算一下她能够摘到的苹果的数目。假设她碰到苹果，苹果就会掉下来。 Input: 输入包括两行数据。第一行包含10个100到200之间（包括100和200）的整数（以厘米为单位）分别表示10个苹果到地面的高度，两个相邻的整数之间用一个空格隔开。第二行只包括一个100到120之间（包含100和120）的整数（以厘米为单位），表示陶陶把手伸直的时候能够达到的最大高度。 Output: 输出包括一行，这一行只包含一个整数，表示陶陶能够摘到的苹果的数目。 Sample Input: 100 200 150 140 129 134 167 198 200 111 110 Copy Sample Output: 5 Copy Note: 每个测试点1s import java.util.List; import java.util.ArrayList; import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner s = new Scanner(System.in); List apples = new ArrayList<>(); int i = 0; while (i++ A 税收与补贴问题 Description: 每样商品的价格越低，其销量就会相应增大。现已知某种商品的成本及其在若干价位上的销量（产品不会低于成本销售），并假设相邻价位间销量的变化是线性的且在价格高于给定的最高价位后，销量以某固定数值递减。（我们假设价格及销售量都是整数） 对于某些特殊商品，不可能完全由市场去调节其价格。这时候就需要政府以税收或补贴的方式来控制。（所谓税收或补贴就是对于每个产品收取或给予生产厂家固定金额的货币）问题求解： 你是某家咨询公司的项目经理，现在你已经知道政府对某种商品的预期价格，以及在各种价位上的销售情况。要求你确定政府对此商品是应收税还是补贴的最少金额（也为整数），才能使商家在这样一种政府预期的价格上，获取相对其他价位上的最大总利润。 总利润=单位商品利润*销量 单位商品利润=单位商品价格-单位商品成本（-税金 or +补贴） Input: 输入的第一行为政府对某种商品的预期价，第二行有两个整数，第一个整数为商品成本，第二个整数为以成本价销售时的销售量，以下若干行每行都有两个整数，第一个为某价位时的单价，第二个为此时的销量，以一行-1，-1表示所有已知价位及对应的销量输入完毕，输入的最后一行为一个单独的整数表示在已知的最高单价外每升高一块钱将减少的销量。 Output: 输出有两种情况：若在政府预期价上能得到最大总利润，则输出一个单独的整数，数的正负表示是补贴还是收税，数的大小表示补贴或收税的金额最小值。若有多解，取绝对值最小的输出。 如在政府预期价上不能得到最大总利润，则输出“NO SOLUTION”。 Sample Input: 31 28 130 30 120 31 110 -1 -1 15 Copy Sample Output: 4 Copy Note: 1 second import java.util.HashMap; import java.util.Map; import java.util.Scanner; public class MaxMin { public static void main(String[] args) { Scanner s = new Scanner(System.in); int maxLiRun = 0; int zuiZhongPrice = 0; int zhengFu; zhengFu = s.nextInt(); int chengBen = s.nextInt(); int chengX = s.nextInt(); int s1 =s.nextInt(); int s2 =s.nextInt(); while (s1!= -1) { int LiRun = (s1 - chengBen) * s2; if (LiRun > maxLiRun) { maxLiRun = LiRun; zuiZhongPrice = s1; } s1 = s.nextInt(); s2 = s.nextInt(); } int dec = s.nextInt(); if (zuiZhongPrice!=zhengFu) System.out.println(\"NO SOLUTION\"); else System.out.println(Math.abs(chengBen-zuiZhongPrice)); } } D Hanoi双塔问题 Description: 给定A,B,C三根足够长的细柱，在A柱上放有2n个中间有孔的圆盘，共有n个不同的尺寸，每个尺寸都有两个相同的圆盘，注意这两个圆盘是不加区分的。现要将这些圆盘移到C柱上，在移动过程中可放在B柱上暂存。要求: (1)每次只能移动一个圆盘； (2) A、B、C三根细柱上的圆盘都要保持上小下大的顺序； 任务:设An为2n个圆盘完成上述任务所需的最少移动次数，对于输入的n，输出An。 Input: 输入为一个正整数n，表示在A柱上放有2n个圆盘。 Output: 输出文件hanoi.out仅一行，包含一个正整数，为完成上述任务所需的最少移动次数An。 Sample Input: 1 Copy Sample Output: 2 Copy Sample Input: 2 Copy Sample Output: 6 Copy Note: 1s 对于50%的数据， 1 对于100% 数据， 1 提示:设法建立An与An-1的递推关系式。 import java.io.FileOutputStream; import java.io.IOException; import java.util.Scanner; public class Main { public static void main(String[] args) throws IOException { Scanner s = new Scanner(System.in); int n = s.nextInt(); int result = (int) ((Math.pow(2,n)-1)*2); FileOutputStream file = new FileOutputStream(\"hanoi.out\"); file.write(result); } } //竟然outOfMemoryError import java.io.FileOutputStream; import java.io.IOException; import java.util.Scanner; public class Main { public static void main(String[] args) throws IOException { Scanner s = new Scanner(System.in); int n = s.nextInt(); int pow=2; while (--n>0){ pow*=2; } int result = (pow-1)*2; FileOutputStream file = new FileOutputStream(\"hanoi.out\"); file.write(result); file.close(); } } B 表达式的值 Description: 对于 1 位二进制变量定义两种运算： 运算的优先级是： \\1. 先计算括号内的，再计算括号外的。 \\2. “×”运算优先于“⊕”运算，即计算表达式时，先计算×运算，再计算⊕运算。 例如：计算表达式A⊕B × C 时，先计算B × C，其结果再与A 做⊕运算。 现给定一个未完成的表达式，例如_+(*)，请你在横线处填入数字0 或者1，请问 有多少种填法可以使得表达式的值为0。 Input: 共2 行。 第 1 行为一个整数L( 0≤L≤100,000 )，表示给定的表达式中除去横线外的运算符和括号的个数。 第 2 行为一个字符串包含L 个字符，其中只包含’（’、’）’、’+’、’’这4 种字符，其中’ （’、’）’是左右括号，’+’、’’分别表示前面定义的运算符“⊕”和“×”。这行字符按顺序 给出了给定表达式中除去变量外的运算符和括号。 Output: 共1 行。包含一个整数，即所有的方案数。注意：这个数可能会很大，请输出方案数对10007 取模后的结果。 Sample Input: 4 +(*) Copy Sample Output: 3 Copy Note: 每个测试点1s。 C 逛公园 Description: 策策同学特别喜欢逛公园。公园可以看成一张 NN 个点 MM 条边构成的有向图，且没有自环和重边。其中 11 号点是公园的入口，NN 号点是公园的出口，每条边有一个非负权值，代表策策经过这条边所要花的时间。策策每天都会去逛公园，他总是从 11 号点进去，从 NN 号点出来。 策策喜欢新鲜的事物，他不希望有两天逛公园的路线完全一样，同时策策还是一个特别热爱学习的好孩子，他不希望每天在逛公园这件事上花费太多的时间。如果11号点到NN号点的最短路长为dd，那么策策只会喜欢长度不超过d+Kd+K的路线。策策同学想知道总共有多少条满足条件的路线，你能帮帮他吗？ 为避免输出过大，答案对PP取模。如果有无穷多条合法的路线，请输出−1−1。 Input: 第一行包含一个整数 TT, 代表数据组数。接下来TT组数据，对于每组数据： 第一行包含四个整数 NN, MM, KK, PP，每两个整数之间用一个空格隔开。 接下来MM行，每行三个整数aiai, bibi, cici，代表编号为aiai, bibi的点之间有一条权值为 cici的有向边，每两个整数之间用一个空格隔开。 Output: 输出文件包含 TT 行，每行一个整数代表答案。 Sample Input: 2 5 7 2 10 1 2 1 2 4 0 4 5 2 2 3 2 3 4 1 3 5 2 1 5 3 2 2 0 10 1 2 0 2 1 0 Copy Sample Output: 3 -1 Copy Note: E 飞扬的小鸟 Description: Flappy Bird 是一款风靡一时的休闲手机游戏。玩家需要不断控制点击手机屏幕的频率来调节小鸟的飞行高度，让小鸟顺利通过画面右方的管道缝隙。如果小鸟一不小心撞到了水管或者掉在地上的话，便宣告失败。 为了简化问题，我们对游戏规则进行了简化和改编： 游戏界面是一个长为 n，高为 m 的二维平面，其中有k 个管道（忽略管道的宽度）。 小鸟始终在游戏界面内移动。小鸟从游戏界面最左边 任意整数高度位置出发，到达游戏界面最右边时，游戏完成。 小鸟每个单位时间沿横坐标方向右移的距离为 1，竖直移动的距离由玩家控制。如果点击屏幕，小鸟就会上升一定高度 X，每个单位时间可以点击多次，效果叠加； 如果不点击屏幕，小鸟就会下降一定高度 Y。小鸟位于横坐标方向不同位置时，上 升的高度 X 和下降的高度 Y 可能互不相同。 小鸟高度等于 0 或者小鸟碰到管道时，游戏失败。小鸟高度为 m 时，无法再上升。 现在，请你判断是否可以完成游戏。如果可以，输出最少点击屏幕数；否则，输出小鸟最多可以通过多少个管道缝隙。 Input: 第 1 行有 3 个整数 n，m，k，分别表示游戏界面的长度，高度和水管的数量，每两个 整数之间用一个空格隔开； 接下来的 n 行，每行 2 个用一个空格隔开的整数 X 和 Y，依次表示在横坐标位置 0~n-1 上玩家点击屏幕后，小鸟在下一位置上升的高度 X，以及在这个位置上玩家不点击屏幕时， 小鸟在下一位置下降的高度 Y。 接下来 k 行，每行 3 个整数 P，L，H，每两个整数之间用一个空格隔开。每行表示一个管道，其中 P 表示管道的横坐标，L 表示此管道缝隙的下边沿高度为 L，H 表示管道缝隙上边沿的高度（输入数据保证 P 各不相同，但不保证按照大小顺序给出）。 Output: 共两行。 第一行，包含一个整数，如果可以成功完成游戏，则输出 1，否则输出 0。 第二行，包含一个整数，如果第一行为 1，则输出成功完成游戏需要最少点击屏幕数，否则，输出小鸟最多可以通过多少个管道缝隙。 Sample Input: 10 10 6 3 9 9 9 1 2 1 3 1 2 1 1 2 1 2 1 1 6 2 2 1 2 7 5 1 5 6 3 5 7 5 8 8 7 9 9 1 3 Copy Sample Output: 1 6 Copy Sample Input: 10 10 4 1 2 3 1 2 2 1 8 1 8 3 2 2 1 2 1 2 2 1 2 1 0 2 6 7 9 9 1 4 3 8 10 Copy Sample Output: 0 3 Copy Note: 对于 30%的数据：5≤n≤10，5≤m≤10，k=0，保证存在一组最优解使得同一单位时间最多点击屏幕 3 次； 对于 50%的数据：5≤n≤20，5≤m≤10，保证存在一组最优解使得同一单位时间最多点击屏幕 3 次； 对于 70%的数据：5≤n≤1000，5≤m≤100； 对于 100%的数据：5≤n≤10000，5≤m≤1000，0≤k 如下图所示，蓝色直线表示小鸟的飞行轨迹，红色直线表示管道。 F 子串 Description: 有两个仅包含小写英文字母的字符串 A 和 B。现在要从字符串 A 中取出 k 个互不重叠的非空子串，然后把这 k 个子串按照其在字符串 A 中出现的顺序依次连接起来得到一 个新的字符串，请问有多少种方案可以使得这个新串与字符串 B 相等？注意：子串取出的位置不同也认为是不同的方案。 Input: 第一行是三个正整数 n，m，k，分别表示字符串 A 的长度，字符串 B 的长度，以及问 题描述中所提到的 k，每两个整数之间用一个空格隔开。第二行包含一个长度为 n 的字符串，表示字符串 A。 第三行包含一个长度为 m 的字符串，表示字符串 B。 Output: 输出共一行，包含一个整数，表示所求方案数。由于答案可能很大，所以这里要求输 出答案对 1,000,000,007 取模的结果。 Sample Input: 6 3 1 aabaab aab Copy Sample Output: 2 Copy Sample Input: 6 3 2 aabaab aab Copy Sample Output: 7 Copy Sample Input: 6 3 3 aabaab aab Copy Sample Output: 7 Copy Note: 对于第 1 组数据：1≤n≤500，1≤m≤50，k=1； 对于第 2 组至第 3 组数据：1≤n≤500，1≤m≤50，k=2； 对于第 4 组至第 5 组数据：1≤n≤500，1≤m≤50，k=m； 对于第 1 组至第 7 组数据：1≤n≤500，1≤m≤50，1≤k≤m； 对于第 1 组至第 9 组数据：1≤n≤1000，1≤m≤100，1≤k≤m； 对于所有 10 组数据：1≤n≤1000，1≤m≤200，1≤k≤m。 样例 1：aab aab / aab aab 样例 2：a ab aab / a aba ab / a a ba ab / aab a ab aa b aab / aa baa b / aab aa b 样例 3：a a b aab / a a baa b / a ab a a b / a aba a b a a b a a b / a a ba a b / aab a a b G 运输计划 Description: 公元 2044 年，人类进入了宇宙纪元。L 国有 nn 个星球，还有 n−1n−1 条双向航道，每条航道建立在两个星球之间，这 n−1n−1 条 航道连通了 L 国的所有星球。 小 P 掌管一家物流公司，该公司有很多个运输计划，每个运输计划形如：有一艘物 流飞船需要从 uiui 号星球沿最快的宇航路径飞行到 vivi 号星球去。显然，飞船驶过一条航道是需要时间的，对于航道 jj，任意飞船驶过它所花费的时间为 tjtj，并且任意两艘飞船之间不会产生任何干扰。 为了鼓励科技创新，L 国国王同意小 PP 的物流公司参与 L 国的航道建设，即允许小 P 把某一条航道改造成虫洞，飞船驶过虫洞不消耗时间。 在虫洞的建设完成前小 P 的物流公司就预接了 mm 个运输计划。在虫洞建设完成后， 这 mm 个运输计划会同时开始，所有飞船一起出发。当这 mm 个运输计划都完成时，小 P 的 物流公司的阶段性工作就完成了。 如果小 P 可以自由选择将哪一条航道改造成虫洞，试求出小 P 的物流公司完成阶段性工作所需要的最短时间是多少？ Input: 第一行包括两个正整数 nn、mm，表示 L 国中星球的数量及小 P 公司预接的运输计划的 数量，星球从 11 到 nn 编号。 接下来 n−1n−1 行描述航道的建设情况，其中第 ii 行包含三个整数 aiai, bibi 和 titi，表示第 ii 条双向航道修建在 aiai 与 bibi 两个星球之间，任意飞船驶过它所花费的时间为 titi。 接下来 mm 行描述运输计划的情况，其中第 jj 行包含两个正整数 ujuj 和 vjvj，表示第 jj 个 运输计划是从 ujuj 号星球飞往 vjvj 号星球。 Output: 共 1 行，包含 1 个整数，表示小 P 的物流公司完成阶段性工作所需要的最短时间。 Sample Input: 6 3 1 2 3 1 6 4 3 1 7 4 3 6 3 5 5 3 6 2 5 4 5 Copy Sample Output: 11 Copy Sample Input: 50 100 1 2 784 2 3 311 2 4 781 1 5 499 5 6 511 2 7 355 4 8 534 8 9 418 4 10 806 6 11 710 5 12 382 9 13 144 2 14 774 8 15 674 3 16 827 10 17 440 8 18 357 6 19 183 9 20 930 1 21 600 10 22 727 2 23 496 11 24 263 2 25 932 9 26 799 2 27 115 2 28 402 3 29 777 29 30 653 5 31 160 7 32 910 28 33 698 8 34 665 12 35 342 4 36 509 9 37 38 24 38 501 1 39 873 16 40 406 5 41 83 9 42 248 33 43 651 19 44 834 5 45 567 15 46 200 45 47 981 10 48 813 47 49 423 49 50 404 31 37 41 17 8 22 19 11 35 37 1 49 18 41 22 37 10 41 32 23 4 4 48 35 31 36 30 50 27 29 41 39 42 24 42 46 37 28 41 42 50 7 38 49 21 43 49 50 29 29 19 37 29 10 27 40 16 9 12 38 42 38 28 1 27 45 17 46 9 6 23 3 47 35 39 5 50 49 7 13 16 28 50 37 18 44 27 35 29 11 49 36 28 48 33 41 37 28 16 30 18 50 45 10 24 22 31 15 48 2 18 46 26 42 36 6 8 28 50 30 38 19 28 21 1 42 16 41 25 45 48 36 25 26 33 47 34 1 8 49 34 8 42 48 29 40 40 40 41 7 34 15 33 29 1 45 34 14 12 35 22 25 9 5 11 16 50 18 16 24 29 19 9 10 27 20 49 9 33 42 7 5 6 15 43 17 2 9 45 10 26 37 27 3 39 36 18 15 44 17 Copy Sample Output: 4645 Copy Note: 一共有20组数据。 其中n的取值依次为：100，100，100，2000，1000，2000，3000，1000，2000，3000，80000，100000，70000，80000，90000，100000，80000，90000，100000，300000。 其中m的取值依次为：1，100，100，1，1000，2000，3000，1000，2000，3000，1，1，70000，80000，90000，100000，80000，90000，100000，300000。 其中第2，5，6，7，13，14，15，16组数据满足：第 i 条航道连接 i 号星球与 i+1 号星球。 输入输出样例 1 说明。 　　将第 1 条航道改造成虫洞：则三个计划耗时分别为：11、12、11，故需要花费的时 间为 12。 　　将第 2 条航道改造成虫洞：则三个计划耗时分别为：7、15、11，故需要花费的时 间为 15。 　　将第 3 条航道改造成虫洞：则三个计划耗时分别为：4、8、11，故需要花费的时间 为 11。 　　将第 4 条航道改造成虫洞：则三个计划耗时分别为：11、15、5，故需要花费的时 间为 15。 　　将第 5 条航道改造成虫洞：则三个计划耗时分别为：11、10、6，故需要花费的时 间为 11。 　　故将第 3 条或第 5 条航道改造成虫洞均可使得完成阶段性工作的耗时最短，需要花 费的时间为 11。 "},"博客/":{"url":"博客/","title":"博客","keywords":"","body":"Introduction "},"博客/next主题配置.html":{"url":"博客/next主题配置.html","title":"Next主题配置","keywords":"","body":"hexo文档 next文档 如何更改字体？ 参考 NexT 从 5.0.1 版本开始提供一个 字体定制特性， 请先查看此特性是否能满足你的需求。以下的修改将覆盖 字体定制 的特性。 编辑主题下的 source/css/_variables/custom.styl 文件，新增两个变量： // 标题，修改成你期望的字体族 $font-family-headings = Georgia, sans // 修改成你期望的字体族 $font-family-base = \"Microsoft YaHei\", Verdana, sans-serif // 代码字体 $code-font-family = \"Input Mono\", \"PT Mono\", Consolas, Monaco, Menlo, monospace // 正文字体的大小 $font-size-base = 16px // 代码字体的大小 $code-font-size = 13px 字体行高 themes/next/source/css/_variables/base.styl // Global line height $line-height-base = 1.6; $line-height-code-block = 1.3; // Can't be less than 1.3; 如何更改内容区域的宽度？ NexT 对于内容的宽度的设定如下： 700px，当屏幕宽度 900px，当屏幕宽度 >= 1600px 移动设备下，宽度自适应 如果你需要修改内容的宽度，同样需要编辑样式文件。 编辑主题的 source/css/_variables/custom.styl 文件，新增变量： // 修改成你期望的宽度 $content-desktop = 700px // 当视窗超过 1600px 后的宽度 $content-desktop-large = 900px 文本居中的引用 此标签将生成一个带上下分割线的引用，同时引用内文本将自动居中。 文本居中时，多行文本若长度不等，视觉上会显得不对称，因此建议在引用单行文本的场景下使用。 例如作为文章开篇引用 或者 结束语之前的总结引用。 使用方式 HTML方式：使用这种方式时，给 img 添加属性 class=\"blockquote-center\" 即可。 标签方式：使用 centerquote 或者 简写 cq。 此标签要求 NexT 的版本在 0.4.5 或以上。 若你正在使用的版本比较低，可以选择使用 HTML 方式。 标签调用方法 blah blah blah {% centerquote %}blah blah blah{% endcenterquote %} {% cq %} blah blah blah {% endcq %} 动态背景的设置 参考 透明色：transparent 文章加密 找到themes->next->layout->_partials->head.swig文件，加入以下代码 按道理是添加在任何地方都行，但是推荐加在所有的``标签之后 (function(){ if(''){ if (prompt('请输入文章密码') !== ''){ alert('密码错误！'); history.back(); } } })(); 需要加密的markdown文章开头加上 password: password 鼠标点击小红心的设置 将 love.js 文件添加到 hemes extsourcejssrc 文件目录下。 找到 hemes extlayout_layout.swing 文件， 在文件的后面， 标签之前 添加以下代码： 自定义hexo new生成md文件的选项 在/scaffolds/post.md文件中添加： --- title: date: tags: categories: copyright: true permalink: 01 top: 0 password: --- 隐藏网页底部powered By Hexo / 强力驱动 打开themes/next/layout/_partials/footer.swig,使用””隐藏之间的代码即可，或者直接删除。 {{ __(footer.powered, Hexo) }} {{ __(footer.theme) }}- NexT.{{ theme.scheme }} --> 一些命令的说明 命令hexo g之后，会把source文件里的.md格式的文件渲染为html文件并放到public下面； 命令hexo d之后，会把public下面的所有文件提交到对应的XXX.github.io这个仓库； 使用阿里图标库 先添加到购物车，新建项目 使用font class下载到本地 解压找到iconfont.css文件 复制其代码到blog/source/_data/styles.styl中 在next主题配置文件中取消下面的注释 custom_file_path: #head: source/_data/head.swig #header: source/_data/header.swig #sidebar: source/_data/sidebar.swig #postMeta: source/_data/post-meta.swig #postBodyEnd: source/_data/post-body-end.swig #footer: source/_data/footer.swig #bodyEnd: source/_data/body-end.swig #variable: source/_data/variables.styl #mixin: source/_data/mixins.styl style: source/_data/styles.styl #取消这里的注释 稍微修改styles.styl里面的代码 示例 @font-face {font-family: \"iconfont\"; src: url('iconfont.eot?t=1576244608406'); /* IE9 */ src: url('iconfont.eot?t=1576244608406#iefix') format('embedded-opentype'), /* IE6-IE8 */ url('data:application/x-font-woff2;charset=utf-8;base64,d09GMgABAAAAAAUMAAsAAAAACeAAAATAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHEIGVgCDBgqHQIVbATYCJAMMCwgABCAFhG0HPRsoCCMRdnNvQpH9M8Gm87RQMu0pGFHV611amw5Gxfo+PzHyykqLpN8ET99Y+7Mzt6fSIIlGiKaWCF0TlK4heqWR8M4jkm/498xXKKlS8ZScxLWD/LnlNjebgx5cDAACYHPNkerNiAj1pHZTQA7QPqb4mGbk81xOm88Dmx8olzGX7YlHvQDjgAIda1CU3QFWIIFKTC3Da12qw94NASKUUod0dA1MEMIgWoGyg93tVUIJG1bBEUJGXzDTkAsQIOTO2GcAnHufl19iJASOgEJGjgzt3KDl2eLZSfH/OAsODciH8wD8PFCgDjCQpULfDNAgUYcSUXVWne8xBDdUuPjfk2kaT//wwCEgHqKLYXaV1h2U3JJF+gpQHLX84l73QBKkAWR1AIpAGN9o3vcSwg2XIGKZPETpM8qD2TzGJvRqN2q71t6kpnBVHUxQuh44iZEa2tW8AttmoWnois1BqpwrtqwyxC5zOYy96hkYHsKRsrtBDSjFDKIoL6O1iR00q/AEGUEBdgMJWThitp1U7UjZZWUYgqJwteXWMoyZq9U2EXo1FddT7HpbgXNNwI4UO+7SnKqgV6vPllPqgRWSlpQsImkNzWhPlxIDrj2zXX9uv/q025UnPY8Wbj9/PYT2YB5HgAN0azJa69UooXZ3BJEuiLTR0LE8V5CrZScaT1EqUuWCtiWY1EcLvYHeNsxDNfRwa3tRNzqoDrbXw15ipa5OB3f5X7d5joyuSy4H5jHQbdrVV+OtHuxYkWuNzrn2JEwkEoy2qatkbYstMri+wzAkYWjStYQFo5q//P7Iuw+lviINAFyVNwIc/zh86wP5bHeIG1oA8DOEZFD+8/HPu+koYVUEH9wTr5R+6nx2eN7haWh4LIKvWQiFrEGagj/lcpWrlKAAWYXAFtmLWLsUdOy32L/xNO3LCw7h7oIahsOq4DtLx5/ppuCJED9fiBdbcPPAqXx/ntEvRsmP7TlBenGK1OgeN+CG5Rk+wFeZnOU3R5+W81098YqWlxGjxVjg//SbXB8f7k0QOxJbFf2mE84Efz+npCB8/Xt/Mn6pUOhPRIRUCqr6izt2XNLsfYVsqFvkw3bM/TxDhky1rVomHlJXxUFi43K7QhMetfVNf2cfquQONNzCl7YPmMTzRzYmSOaKRMA/1wmLyEoSa+N4nZ3hx88LHtpjDM2fWdlxs33F8uuuGX01ez/HhcsdVjSHkyNyWgBA8a+OUtFv9h0eVjdn02Tafwg2AN7023CPV8QNaBEhHDSW/1Tyhg2mKYldTZFZMiOtXBN+ZRKQCEGKgIQyfHUP5CHyCCFBDnAEKYESooxu7DoEiFIPT4hmRKile36ULIdAEQsDNRwhCClu4UhwByXFC93YnwhQ4A+elCgiTLGUK0apkKtGbAlzxgqKP5iya6XpZOGX31C965ziSo/7QvImDHEQpdNHbJGGGOM/KmGWIKlr4ID2w7ruoKfOYsmBZu6XYSiLHhSUXTMSoy1hzlhB8QdTdq10WrPIvP+G6l3nVEGoir6QvOkc4iBqQD/q2kaES7nHf1TCLEFS18ABebCmiQ764m4WSw50h1i/DHEz2VQXTG9o7m8bEBmRiTp2omLMt6e0MLWx6jaz0lftaAQ=') format('woff2'), url('iconfont.woff?t=1576244608406') format('woff'), url('iconfont.ttf?t=1576244608406') format('truetype'), /* chrome, firefox, opera, Safari, Android, iOS 4.2+ */ url('iconfont.svg?t=1576244608406#iconfont') format('svg'); /* iOS 4.1- */ } .fa-custom { font-family: \"iconfont\" !important; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; } .bilibili:before { content: \"\\e64e\"; font-size: 20px; //可以调整大小 } .csdn:before { content: \"\\e638\"; } 最后在这里引用即可 social: GitHub: https://github.com/BluePrintYang || github E-Mail: mailto:yll1671158@163.com || envelope CSDN: https://blog.csdn.net/bluepyang || custom csdn Bilibili: https://space.bilibili.com/130954022 || custom bilibili 待办 文章字体修改，布局 标签云 支持更多markdown语法 自定义icon :star: 2^2^ H~2~O $$ 2+2=4 $$ "},"博客/一些问题的记录.html":{"url":"博客/一些问题的记录.html","title":"一些问题的记录","keywords":"","body":"标题格式问题 如果使用1号标题（h1）是无法在导航中链接的 从#2标题开始 报错 FATAL Something's wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.html Template render error: (unknown path) unexpected end of file at Object._prettifyError (D:\\hexo\\newblog\\node_modules\\nunjucks\\src\\lib.js:36:11) at Template.render (D:\\hexo\\newblog\\node_modules\\nunjucks\\src\\environment.js:542:21) at Environment.renderString (D:\\hexo\\newblog\\node_modules\\nunjucks\\src\\environment.js:380:17) at D:\\hexo\\newblog\\node_modules\\hexo\\lib\\extend\\tag.js:120:48 at tryCatcher (D:\\hexo\\newblog\\node_modules\\bluebird\\js\\release\\util.js:16:23) at Function.Promise.fromNode.Promise.fromCallback (D:\\hexo\\newblog\\node_modules\\bluebird\\js\\release\\promise.js:209:30) at Tag.render (D:\\hexo\\newblog\\node_modules\\hexo\\lib\\extend\\tag.js:120:18) at Object.onRenderEnd (D:\\hexo\\newblog\\node_modules\\hexo\\lib\\hexo\\post.js:287:20) at D:\\hexo\\newblog\\node_modules\\hexo\\lib\\hexo\\render.js:64:19 at tryCatcher (D:\\hexo\\newblog\\node_modules\\bluebird\\js\\release\\util.js:16:23) at Promise._settlePromiseFromHandler (D:\\hexo\\newblog\\node_modules\\bluebird\\js\\release\\promise.js:547:31) at Promise._settlePromise (D:\\hexo\\newblog\\node_modules\\bluebird\\js\\release\\promise.js:604:18) at Promise._settlePromise0 (D:\\hexo\\newblog\\node_modules\\bluebird\\js\\release\\promise.js:649:10) at Promise._settlePromises (D:\\hexo\\newblog\\node_modules\\bluebird\\js\\release\\promise.js:729:18) at _drainQueueStep (D:\\hexo\\newblog\\node_modules\\bluebird\\js\\release\\async.js:93:12) at _drainQueue (D:\\hexo\\newblog\\node_modules\\bluebird\\js\\release\\async.js:86:9) at Async._drainQueues (D:\\hexo\\newblog\\node_modules\\bluebird\\js\\release\\async.js:102:5) at Immediate.Async.drainQueues (D:\\hexo\\newblog\\node_modules\\bluebird\\js\\release\\async.js:15:14) at processImmediate (internal/timers.js:439:21) 原因，一篇markdown里面用了不规范的语法 {% cq %}咦？这里有 :one: 条分割线 :arrow_down: {% cq %} 正确用法 {% cq %} blah blah blah {% endcq %} "},"学习java/":{"url":"学习java/","title":"学习Java","keywords":"","body":"Introduction "},"学习java/AQS.html":{"url":"学习java/AQS.html","title":"AQS","keywords":"","body":" 突然发现一个很有意思的现象，学的东西越多，就会发现以前的内容很浅显，甚至是错的。当时明明觉得豁然开朗了，现在看来其实还是蒙在鼓中。这种感觉之前也有过，上初中后说小学学的知识是错误的，上高中后说初中是错的……真的是错的吗？或许是的。但是，如果一开始就讲最正确最新的理论知识，恐怕要“劝退”很多人。这其实也是一个不断进步，不断改正错误的过程吧。哪有什么真正的对与错，我们现在认为正确的事，未来就一定也是正确的吗？学无止境，就是这个道理吧！ 言归正传，继续学习Java并发相关知识 AQS源码 概述 首先来看看AQS（AbstractQueuedSynchronizer）的类图 AQS是一个抽象类，继承了抽象类AbstractOwnableSynchronizer，实现了序列化接口 有两个内部类Node和ConditionObject 抽象类AOS public abstract class AbstractOwnableSynchronizer implements java.io.Serializable { //序列化id private static final long serialVersionUID = 3737899427754241961L; //空参构造方法 protected AbstractOwnableSynchronizer() { } //独占模式同步的当前所有者 private transient Thread exclusiveOwnerThread; // 设置当前拥有独占访问权的线程 protected final void setExclusiveOwnerThread(Thread thread) { exclusiveOwnerThread = thread; } //返回当前拥有独占访问权的线程 protected final Thread getExclusiveOwnerThread() { return exclusiveOwnerThread; } } AQS源码 Fileds和一些简单Methods public abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer implements java.io.Serializable { private static final long serialVersionUID = 7373984972572414691L; /* 空参构造方法。 * 官方描述： Creates a new instance with initial synchronization state of zero. */ protected AbstractQueuedSynchronizer() { } /*内部类Node在下面*/ //等待队列头节点，只能通过setHead方法修改 //如果head存在，waitStatus不会是CANCELED private transient volatile Node head; //等待队列尾结点，只能通过enq方法修改，添加新的等待结点 private transient volatile Node tail; //同步器状态 private volatile int state; /*省略state的setter&getter*/ //CAS protected final boolean compareAndSetState(int expect, int update) { // 调用unsafe的CAS return unsafe.compareAndSwapInt(this, stateOffset, expect, update); } //自旋的纳秒阈值 static final long spinForTimeoutThreshold = 1000L; /*省略一些方法，下面详解*/ //支持CAS操作 private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final long stateOffset; private static final long headOffset; private static final long tailOffset; private static final long waitStatusOffset; private static final long nextOffset; static { try { stateOffset = unsafe.objectFieldOffset (AbstractQueuedSynchronizer.class.getDeclaredField(\"state\")); headOffset = unsafe.objectFieldOffset (AbstractQueuedSynchronizer.class.getDeclaredField(\"head\")); tailOffset = unsafe.objectFieldOffset (AbstractQueuedSynchronizer.class.getDeclaredField(\"tail\")); waitStatusOffset = unsafe.objectFieldOffset (Node.class.getDeclaredField(\"waitStatus\")); nextOffset = unsafe.objectFieldOffset (Node.class.getDeclaredField(\"next\")); } catch (Exception ex) { throw new Error(ex); } } } 内部类Node static final class Node { //指示节点正在共享模式下等待的标记 static final Node SHARED = new Node(); //指示节点正在以独占模式等待的标记 static final Node EXCLUSIVE = null; //waitStatus值，指示线程已取消 static final int CANCELLED = 1; //waitStatus值，指示后续线程需要释放 static final int SIGNAL = -1; //waitStatus值，指示线程正在等待条件 static final int CONDITION = -2; //waitStatus值，指示下一次获取的Shared应该无条件传播 static final int PROPAGATE = -3; volatile int waitStatus; volatile Node prev; volatile Node next; volatile Thread thread; Node nextWaiter; final boolean isShared() { return nextWaiter == SHARED; } final Node predecessor() throws NullPointerException { Node p = prev; if (p == null) throw new NullPointerException(); else return p; } Node() { // 用于建立初始标头或SHARED标记 } Node(Thread thread, Node mode) { // Used by addWaiter this.nextWaiter = mode; this.thread = thread; } Node(Thread thread, int waitStatus) { // Used by Condition this.waitStatus = waitStatus; this.thread = thread; } } 排队工具方法Queuing utilities enq方法 插入node到队列 private Node enq(final Node node) { for (;;) { Node t = tail; if (t == null) { // Must initialize if (compareAndSetHead(new Node())) tail = head; } else { node.prev = t; if (compareAndSetTail(t, node)) { t.next = node; return t; } } } } addwaiter方法 为当前线程和给定模式创建并排队节点 private Node addWaiter(Node mode) { Node node = new Node(Thread.currentThread(), mode); // Try the fast path of enq; backup to full enq on failure Node pred = tail; if (pred != null) { node.prev = pred; if (compareAndSetTail(pred, node)) { pred.next = node; return node; } } enq(node); return node; } setHead方法 设置头结点 private void setHead(Node node) { head = node; node.thread = null; node.prev = null; } unparkSuccessor方法 //Wakes up node's successor, if one exists. private void unparkSuccessor(Node node) { int ws = node.waitStatus; if (ws 0) { s = null; for (Node t = tail; t != null && t != node; t = t.prev) if (t.waitStatus doReleaseShared方法 private void doReleaseShared() { for (;;) { Node h = head; if (h != null && h != tail) { int ws = h.waitStatus; if (ws == Node.SIGNAL) { if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) continue; // loop to recheck cases unparkSuccessor(h); } else if (ws == 0 && !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) continue; // loop on failed CAS } if (h == head) // loop if head changed break; } } setHeadAndPropagate方法 private void setHeadAndPropagate(Node node, int propagate) { Node h = head; // Record old head for check below setHead(node); if (propagate > 0 || h == null || h.waitStatus :star:主要方法Main exported methods //Attempts to acquire in exclusive mode. protected boolean tryAcquire(int arg) { throw new UnsupportedOperationException(); } //Attempts to set the state to reflect a release in exclusive mode. protected boolean tryRelease(int arg) { throw new UnsupportedOperationException(); } //Attempts to acquire in shared mode protected int tryAcquireShared(int arg) { throw new UnsupportedOperationException(); } //Attempts to set the state to reflect a release in shared mode protected boolean tryReleaseShared(int arg) { throw new UnsupportedOperationException(); } //Returns true if synchronization is held exclusively with respect to the current (calling) thread. protected boolean isHeldExclusively() { throw new UnsupportedOperationException(); } AQS提供的模板方法 //独占式获取同步状态。如果当前线程获取同步状态成功，则由该方法返回，否则，将会进入同步队列等待，该方法将会调用重写的tryAcquire方法 public final void acquire(int arg) { if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); } //与acquire方法相同，但是该方法响应中断，当前线程未获取到同步状态而进入同步队列中，如果当前线程被中断，则抛出异常 public final void acquireInterruptibly(int arg) throws InterruptedException { if (Thread.interrupted()) throw new InterruptedException(); if (!tryAcquire(arg)) doAcquireInterruptibly(arg); } //在acquireInterruptibly方法的基础上加了超时限制，超时时间内没有获取到同步状态返回false，获取到了返回true public final boolean tryAcquireNanos(int arg, long nanosTimeout) throws InterruptedException { if (Thread.interrupted()) throw new InterruptedException(); return tryAcquire(arg) || doAcquireNanos(arg, nanosTimeout); } //独占式的释放同步状态，该方法会在释放同步状态之后，将同步队列中第一个节点包含的线程唤醒 public final boolean release(int arg) { if (tryRelease(arg)) { Node h = head; if (h != null && h.waitStatus != 0) unparkSuccessor(h); return true; } return false; } //共享式的获取同步状态。如果当前线程未获取到同步状态，将会进入同步队列等待。与独占式获取的主要区别是在同一时刻可以有多个线程获取到同步状态 public final void acquireShared(int arg) { if (tryAcquireShared(arg) = 0 || doAcquireSharedNanos(arg, nanosTimeout); } //共享式的释放同步状态 public final boolean releaseShared(int arg) { if (tryReleaseShared(arg)) { doReleaseShared(); return true; } return false; } //获取等待在同步队列上的线程集合 public final Collection getQueuedThreads() { ArrayList list = new ArrayList(); for (Node p = tail; p != null; p = p.prev) { Thread t = p.thread; if (t != null) list.add(t); } return list; } CAS方法 // CAS head field. Used only by enq. private final boolean compareAndSetHead(Node update) { return unsafe.compareAndSwapObject(this, headOffset, null, update); } // CAS tail field. Used only by enq. private final boolean compareAndSetTail(Node expect, Node update) { return unsafe.compareAndSwapObject(this, tailOffset, expect, update); } // CAS waitStatus field of a node. private static final boolean compareAndSetWaitStatus(Node node,int expect,int update) { return unsafe.compareAndSwapInt(node, waitStatusOffset,expect, update); } // CAS next field of a node. private static final boolean compareAndSetNext(Node node,Node expect,Node update) { return unsafe.compareAndSwapObject(node, nextOffset, expect, update); } "},"学习java/HashMap的简单实现.html":{"url":"学习java/HashMap的简单实现.html","title":"HashMap的简单实现","keywords":"","body":"HashMap的简单使用 public class TestHashMap { public static void main(String[] args) { Map map = new HashMap<>(); map.put(\"a\",\"aaa\"); map.put(\"b\",\"bbb\"); map.put(\"c\",\"ccc\"); map.put(\"d\",\"ddd\"); map.put(\"e\",\"eee\"); System.out.println(map.get(\"a\")); } } //运行结果：aaa HashMap存储Key-Value（键值对）数据 HashMap实现原理 在Java8之前，通过数组+链表实现 Java8中，改为数组+链表+红黑树。当链表长度超过8时，将链表改为红黑树，降低数据查找的时间复杂度 HashMap成员 一个数组，数组里面每个元素都是链表 链表存储对象(Entry)：包括Key，Value，next，hash HashMap简单实现 定义Map接口 public interface MyMap { public V put(K k,V v); public V get(K k); public int size(); interface Entry{ public K getKey(); public V getValue(); } } HashMap简单实现 public class MyHashMap implements MyMap { //数组加链表 private Entry[] table; private int size = 0; private static int defaultLength = 16; public MyHashMap() { table = new Entry[defaultLength]; } @Override public V put(K k, V v) { //1.key进行hash 2.对应数组下标 3.如果是null 4.是否可以存储 int index = hash(k); Entry entry = table[index]; if (null == entry) { table[index] = new Entry<>(k, v, null, index); } else { table[index] = new Entry<>(k, v, entry, index); } size++; return table[index].getValue(); } private int hash(K k) { int index = k.hashCode() % (defaultLength - 1); return Math.abs(index); } @Override public V get(K k) { if (size == 0) { return null; } //hash出来的index 获取到当前Entry对象 判断对象有没有值 比较 在继续查找直到 key hashcode int index = hash(k); Entry entry = getEntry(k, index); return entry == null ? null : entry.getValue(); } private Entry getEntry(K k, int index) { for (Entry entry = table[index]; entry != null; entry = entry.next) { if (entry.hash == index && (k == entry.getKey() || k.equals(entry.getKey()))) { return entry; } } return null; } @Override public int size() { return size; } static class Entry implements MyMap.Entry { K k; V v; MyHashMap.Entry next; int hash; public Entry(K k, V v, MyHashMap.Entry next, int hash) { this.k = k; this.v = v; this.next = next; this.hash = hash; } @Override public K getKey() { return k; } public V getValue() { return v; } } } 测试 public class TestMyHashMap { public static void main(String[] args) { MyMap map = new MyHashMap(); map.put(\"yll\", \"yll\"); System.out.println(map.get(\"yll\")); System.out.println(map.size()); } } /*运行结果： yll 1 */ 这里只实现了Java8之前的数组加链表形式 HashMap注意事项 HashMap是线程不安全的，put方法和扩容时都是不安全的 但是get方法是线程安全的 hash的作用 hashcode通过hash函数计算得到，hashcode就是在hash表中对应的位置 每个对象都有hashcode，将对象的物理地址转换为一个整数，将整数通过hash计算得到hashcode hashCode方法的存在是为了减少equals方法的调用次数，从而提高程序效率 hashCode()与equals() Java的基类Object中的 equals()方法用于判断两个对象是否相等，hashCode()方法用于计算对象的哈希码。equals()和hashCode()都不是final方法，都可以被重写(overwrite) hashCode方法 hashCode()是一个native方法（一个Native Method就是一个java调用非java代码的接口），而且返回值类型是整形 HashMap中的hash函数 static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16); } 这段代码类似作用是为了增加hashcode的随机性 "},"学习java/JavaByteCode.html":{"url":"学习java/JavaByteCode.html","title":"JavaByteCode","keywords":"","body":"Java字节码 源程序 public class Factorial { public static void main(String[] args) { System.out.println(factorial(5)); } private static int factorial(int n) { if (n 编译为.class文件，使用命令javap -v查看字节码如下 Classfile /D:/program/Factorial.class Last modified 2020-6-16; size 503 bytes MD5 checksum 653d943bd262083f1a678567935cda55 Compiled from \"Factorial.java\" public class Factorial minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPER Constant pool: #1 = Methodref #6.#18 // java/lang/Object.\"\":()V #2 = Fieldref #19.#20 // java/lang/System.out:Ljava/io/PrintStream; #3 = Methodref #5.#21 // Factorial.factorial:(I)I #4 = Methodref #22.#23 // java/io/PrintStream.println:(I)V #5 = Class #24 // Factorial #6 = Class #25 // java/lang/Object #7 = Utf8 #8 = Utf8 ()V #9 = Utf8 Code #10 = Utf8 LineNumberTable #11 = Utf8 main #12 = Utf8 ([Ljava/lang/String;)V #13 = Utf8 factorial #14 = Utf8 (I)I #15 = Utf8 StackMapTable #16 = Utf8 SourceFile #17 = Utf8 Factorial.java #18 = NameAndType #7:#8 // \"\":()V #19 = Class #26 // java/lang/System #20 = NameAndType #27:#28 // out:Ljava/io/PrintStream; #21 = NameAndType #13:#14 // factorial:(I)I #22 = Class #29 // java/io/PrintStream #23 = NameAndType #30:#31 // println:(I)V #24 = Utf8 Factorial #25 = Utf8 java/lang/Object #26 = Utf8 java/lang/System #27 = Utf8 out #28 = Utf8 Ljava/io/PrintStream; #29 = Utf8 java/io/PrintStream #30 = Utf8 println #31 = Utf8 (I)V { public Factorial(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.\"\":()V 4: return LineNumberTable: line 5: 0 public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=1, args_size=1 0: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 3: iconst_5 4: invokestatic #3 // Method factorial:(I)I 7: invokevirtual #4 // Method java/io/PrintStream.println:(I)V 10: return LineNumberTable: line 7: 0 line 8: 10 public static int factorial(int); descriptor: (I)I flags: ACC_PUBLIC, ACC_STATIC Code: stack=3, locals=1, args_size=1 0: iload_0 1: iconst_2 2: if_icmpge 7 5: iconst_1 6: ireturn 7: iload_0 8: iload_0 9: iconst_1 10: isub 11: invokestatic #3 // Method factorial:(I)I 14: imul 15: ireturn LineNumberTable: line 10: 0 line 11: 7 StackMapTable: number_of_entries = 1 frame_type = 7 /* same */ } SourceFile: \"Factorial.java\" 一些指令说明 参考：https://en.wikipedia.org/wiki/Java_bytecode_instruction_listings Mnemonic Description aload_0 load a reference onto the stack from local variable 0 invokespecial #1 invoke instance method on object objectref and puts the result on the stack (might be void); the method is identified by method reference index in constant pool (indexbyte1 "},"学习java/Java基础.html":{"url":"学习java/Java基础.html","title":"Java基础","keywords":"","body":"Java基础 Java异常 异常分类 Throwable是Java语言中所有错误或异常的超类。下一层为Error和Exception Error类是指Java运行时系统的内部错误和资源耗尽错误。 Exception有两个分支运行时异常RuntimeException和检查异常CheckException 异常处理方式 throw throws 系统自动抛异常 Throw与Throws的区别 位置不同 throw用在函数上，后面跟异常类，可以跟多个；throws用在函数内，后面跟的是异常对象 功能不同 throws用来声明异常，让调用者只知道该功能可能出现的问题；throw抛出具体的问题对象，执行到throw，功能就结束了 throws表示出现异常的一种可能性，并不一定会发生异常；throw则是抛出了异常，执行throw则一定抛出了某种异常对象 Java反射 Java反射机制是指在运行状态中，对于任意一个类都能知道这个类所有的属性和方法；并且对于任意一个对象，都能够调用它的任意一个方法 运行状态时知道类所有的属性和方法 编译时类型和运行时类型 Person p = new Student();//编译时为Person类，运行时为Student类 反射API Class类 Field类 Method类 Constructor类 反射使用步骤（获取Class对象，调用对象方法） 获取想要操作的类的Class对象 调用Class类中的方法 使用反射API来操作这些信息 获取Class对象的3种方法 调用某个对象getClass()方法 Person p = new Person(); Class aClass = p.getClass(); 调用某个类的class属性来获取该类的Class对象 Class aClass = Person.class; 使用Class类中的forName()静态方法（最安全/性能最好） Class aClass = Class.forName(\"类的全路径\");//最常用 获取了想要操作的类的Class对象后，可以通过Class类中的方法获取并查看该类中的方法和属性 public class MyReflection { public static void main(String[] args) throws ClassNotFoundException { //获取Test类的Class对象 Class aClass = Class.forName(\"interview.Test\"); //获取Test类的所有方法信息 Method[] methods = aClass.getDeclaredMethods(); for (Method m : methods){ System.out.println(m.toString()); } //获取Test类的所有成员属性信息 Field[] fields = aClass.getDeclaredFields(); for (Field f : fields){ System.out.println(f.toString()); } //获取Test类的所有构造方法信息 Constructor[] constructors = aClass.getDeclaredConstructors(); for (Constructor c : constructors){ System.out.println(c.toString()); } } } 创建对象的两种方法 Class对象的newInstance() 使用Class对象的newInstance()方法来创建改Class对象对应的实例，但是这种方法要求该Class对象对应的类有默认的空构造器 调用Constructor对象的newInstance() 先使用Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建Class对象对应类的实例 //获取Test类的Class对象 Class aClass = Class.forName(\"interview.Test\"); //使用.newInstance方法创建对象 Test t = (Test) aClass.newInstance(); //获取构造器方法并创建对象 Constructor c = aClass.getDeclaredConstructor(int.class); //创建对象并设置属性 Test t1 = (Test) c.newInstance(10); Java注解 是Java提供的一种对元程序中元素关联信息和元数据的途径和方法 Annotation是一个接口，程序可以通过反射来获取指定程序中的元素的Annotation对象，然后通过该Annotation对象来获取注解中的元数据信息 4种标准元注解 元注解的作用是负责注解其他注解 @Target修饰对象的赋值范围 可被用于packages，types，类型成员，方法参数和本地变量 @Retention定义被保留的时长 定义注解被保留的时间长短 SOURCE：在源文件中有效 CLASS：在class文件中有效 RUNTIME：在运行时有效 @Document描述-javadoc @Inherited阐述了某个被标注的类型是被继承的 注解处理器 /*定义注解*/ @Target(ElementType.FIELD) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface FruitProvider { /*供应商编号*/ public int id() default -1; /*供应商名称*/ public String name() default \"\"; /*供应商地址*/ public String address() default \"\"; } /*注解使用*/ public class Apple { @FruitProvider(id=1,name = \"江苏红富士集团\",address = \"江苏南京\") private String appleProvider; public String getAppleProvider() { return appleProvider; } public void setAppleProvider(String appleProvider) { this.appleProvider = appleProvider; } } /*注解处理器*/ public class FruitInfoUtil { public static void getFruitInfo(Class aClass) { String strFruitProvider = \"供应商信息\"; Field[] fields = aClass.getDeclaredFields();//通过反射获取处理注解 for (Field field : fields) { if (field.isAnnotationPresent(FruitProvider.class)) { FruitProvider fruitProvider = (FruitProvider) field.getAnnotation(FruitProvider.class); //注解信息的处理地方 strFruitProvider = \" 供应商编号：\" + fruitProvider.id() + \" 供应商名称:\"+fruitProvider.name()+\" 供应商地址：\"+fruitProvider.address(); System.out.println(strFruitProvider); } } } } public class FruitRun { public static void main(String[] args) { FruitInfoUtil.getFruitInfo(Apple.class); } } 泛型 通配符概念 通配符类型中，允许类型参数变化。例如List表示任何泛型List类型，它的类型参数是Father的子类，如List public class Test { public static void main(String[] args) { List list = new ArrayList<>(); test(list);//这里会编译错误 } static void test(List list) { System.out.println(list.get(0)); } class Father { } class Son extends Father{ } } 可以将test函数参数改成List类型 List表示任何泛型List类型，它的类型参数是Son的父类，例如List Java内部类 这是一个普通的Java类，有3个成员变量 public class NestedClass { private static int nestedClassPrivateStaticVar; public int nestedClassPublicVar; protected int nestedClassProtectedVar; } 静态成员类 在里面添加一个静态类StaticMemberClass，StaticMemberClass就是静态成员类 public class NestedClass { private static int nestedClassPrivateStaticVar; public int nestedClassPublicVar; protected int nestedClassProtectedVar; public static void main(String[] args) { //通过类名调用静态内部类的静态方法 StaticMemberClass.getNestedClassPrivateStaticVar(); //通过类名访问静态内部类的静态成员 System.out.println(\"外部类通过类名访问静态内部类的静态成员：\"+StaticMemberClass.staticPrivateValue); } /** * 1.静态成员类StaticMemberClass * ★★★属于整个类，不属于单个实例对象 */ static class StaticMemberClass { //外部类可通过类名访问 private static int staticPrivateValue; //外部类无法访问 public int staticValue; static void getNestedClassPrivateStaticVar() { //可访问外部类的静态成员变量 nestedClassPrivateStaticVar = 0; System.out.println(\"通过静态内部类访问外部类的静态成员变量：\" + nestedClassPrivateStaticVar); } } } //运行结果 //通过静态内部类访问外部类的静态成员变量：0 //外部类通过类名访问静态内部类的静态成员：0 非静态成员类 局部类 匿名内部类 函数式接口：只包含一个抽象方法的接口，可以包含多个默认方法、类方法。 例如：Runnable，ActionListener Lambda表达式 Lambda表达式的目标类型必须是函数式接口 Lambda表达式只能为函数式接口创建对象。Lambda表达式只能实现一个方法 Lambda表达式的结果就是被当成对象 里面的外部变量必须被final修饰 "},"学习java/Java多线程.html":{"url":"学习java/Java多线程.html","title":"Java多线程","keywords":"","body":"线程的生命周期 新建状态 使用new关键词创建一个线程后，处于新建状态，仅由JVM为其分配内存，并初始化其成员变量 就绪状态 线程对象调用了start()方法之后。Java虚拟机会为其创建方法调用栈和程序计数器，等待调度运行 运行状态 就绪状态的线程获得了cpu，开始执行run()方法的线程执行体 阻塞状态 由于某种原因放弃了cpu使用权 分三种情况 等待阻塞：执行wait()方法，进入等待队列 同步阻塞：获取对象同步锁时，同步锁被其他线程占用，JVM会把该线程放入锁池中 其他阻塞：执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求 线程死亡 线程会以三种方式结束，结束后就是死亡状态 正常结束：run()或call()方法执行完成 异常结束：线程抛出一个未捕获的Exception或Error 调用stop：直接调用线程的stop()方法来结束改线程——容易造成死锁，不推荐 线程创建方式 public class ThreadTest { public static void main(String[] args) { //1.继承Thread类 Thread1 thread = new Thread1(); thread.start(); //2.实现Runnable接口 Runnable r = () -> { for (int i = 0; i 线程常用方法 线程的优先级 private static void threadPriority() { //只是修改线程抢到cpu时间片的概率 //并不一定优先级高就能抢到 //优先级是个整数 [1,10] 默认5 ，最高10 Runnable r = () -> { for (int i = 0; i 线程的礼让 /** * 线程的礼让 * 放弃cpu时间片，然后重新抢夺，也可能还是抢到 */ private static void threadYield(){ Runnable r = () ->{ for (int i = 0; i 多线程并发 多线程卖票程序 public class SourceConflict { public static void main(String[] args) { Runnable r = () ->{ while (TicketCenter.restTicket>0){ System.out.println(Thread.currentThread().getName()+\"卖出一张票，剩余\"+--TicketCenter.restTicket+\"张票\"); } }; Thread t1 = new Thread(r,\"Thread1\"); Thread t2 = new Thread(r,\"Thread2\"); Thread t3 = new Thread(r,\"Thread3\"); Thread t4 = new Thread(r,\"Thread4\"); t1.start(); t2.start(); t3.start(); t4.start(); } } class TicketCenter{ public static int restTicket=100; } //运行结果 每次执行结果不同 //Thread4卖出一张票，剩余98张票 //Thread1卖出一张票，剩余97张票 //Thread3卖出一张票，剩余99张票 //Thread2卖出一张票，剩余99张票 //Thread3卖出一张票，剩余94张票 //Thread3卖出一张票，剩余92张票 //Thread1卖出一张票，剩余95张票 //Thread4卖出一张票，剩余96张票 //Thread4卖出一张票，剩余89张票 //…… 结果并不是我们想要得到的，是由于多线程并发时执行顺序导致出现的问题 改进方法1 使用同步代码段 public class SynchronizeDemo { public static void main(String[] args) { Runnable r = () ->{ while (TicketCenter.restTicket>0){ //同步代码段 //synchronized小括号里面可以是对象也可以是类 //但是必须保证所以线程看到的锁是同一个 synchronized (\"\"){ if (TicketCenter.restTicket 改进方法2 使用同步方法 public class SynchronizeFunction { public static void main(String[] args) { Runnable r = SynchronizeFunction::sellTicket; Thread t1 = new Thread(r,\"Thread1\"); Thread t2 = new Thread(r,\"Thread2\"); Thread t3 = new Thread(r,\"Thread3\"); Thread t4 = new Thread(r,\"Thread4\"); t1.start(); t2.start(); t3.start(); t4.start(); } /** * 方法为静态，则同步锁为类.class * 非静态，同步锁为this */ private synchronized static void sellTicket(){ while (TicketCenter.restTicket>0){ System.out.println(Thread.currentThread().getName()+\"卖出一张票，剩余\"+--TicketCenter.restTicket+\"张票\"); } } } //运行结果同上 改进方法3 使用显式锁 public class LockDemo { public static void main(String[] args) { //实例化一个锁对象 ReentrantLock lock = new ReentrantLock(); Runnable r = () -> { while (TicketCenter.restTicket > 0) { lock.lock(); if (TicketCenter.restTicket 死锁 //多个线程彼此持有对方需要的锁标记而不释放自己的锁造成的 public class DeadLock { public static void main(String[] args) { Runnable r1 = ()->{ synchronized (\"A\"){ System.out.println(\"线程1获取了锁A，等待锁B\"); synchronized (\"B\"){ System.out.println(\"线程1同时获取A和B\"); } } }; Runnable r2 = ()->{ synchronized (\"B\"){ System.out.println(\"线程2获取了锁B，等待锁A\"); synchronized (\"A\"){ System.out.println(\"线程2同时获取A和B\"); } } }; Thread t1 = new Thread(r1); Thread t2 = new Thread(r2); t1.start(); t2.start(); } } 解除死锁 /* wait():等待，Object类中的一个方法，当前线程释放自己的锁标记，让出CPU资源，进入等待队列 notify()：通知，Object类中的一个方法，唤醒等待队列中的一个线程（由CPU调度），使这个线程进入锁池 notifyAll()：通知，Object类中的方法，唤醒等待队列中所有线程，并使这些线程进入锁池 */ public class DeadLock2 { public static void main(String[] args) { Runnable r1 = ()->{ synchronized (\"A\"){ try { \"A\".wait(); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"线程1获取了锁A，等待锁B\"); synchronized (\"B\"){ System.out.println(\"线程1同时获取A和B\"); } } }; Runnable r2 = ()->{ synchronized (\"B\"){ System.out.println(\"线程2获取了锁B，等待锁A\"); synchronized (\"A\"){ System.out.println(\"线程2同时获取A和B\"); \"A\".notifyAll(); } } }; Thread t1 = new Thread(r1); Thread t2 = new Thread(r2); t1.start(); t2.start(); } } 单例模式 public class SingletonTest { public static void main(String[] args) { Runnable r = Boss::getBoss; for (int i = 0; i "},"学习java/Java多线程并发.html":{"url":"学习java/Java多线程并发.html","title":"Java多线程并发","keywords":"","body":"Java多线程并发 Java线程实现/创建方法 继承Thread类 Thread类本质是实现了Runnable接口的一个实例，代表一个线程的实例。启动一个线程的唯一方法是通过Thread类的start()方法。start方法是一个native方法（一个Native Method就是一个java调用非java代码的接口） public class MyThread extends Thread { public void run(){ System.out.println(\"MyThread.run()\"); } } MyThread myThread1 = new MyThread(); myThread1.start(); 实现Runnable接口 如果自己的类已经extends另一个类，就无法直接extends Thread，此时可以实现一个Runnable接口 public class MyThread2 extends OtherClass implements Runnable { public void run(){ System.out.println(\"MyThread2.run()\"); } public static void main(String[] args) { /* 启动MyThread2，需要首先实例化一个Thread，并传入自己的MyThread实例 */ MyThread2 myThread2 = new MyThread2(); Thread thread = new Thread(myThread2); thread.start(); /* 事实上，当传入一个Runnable target参数给Thread后，Thread的run()方法就会调用target.run() */ } } ExecutorService、Callable、Future有返回值线程 有返回值的任务必须实现Callable接口，无返回值的任务必须实现Runnable接口。执行Callable任务后，可以获取一个Future的对象，在该对象上调用get就可以获取到Callable任务返回的Object了，再结合线程池接口ExecutorService就可以实现有返回结果的多线程了 public class Pool { public static void main(String[] args) throws ExecutionException, InterruptedException { int taskSize = 3; //创建一个线程池 ExecutorService pool = Executors.newFixedThreadPool(taskSize); //创建多个有返回值的任务 List list = new ArrayList(); for (int i = 0; i 基于线程池的方式 //创建线程池 ExecutorService threadPool = Executors.newFixedThreadPool(10); while (true){ threadPool.execute(new Runnable() { @Override public void run() { System.out.println(Thread.currentThread().getName()+\" is running .. \"); try{ Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } } }); } 4种线程池 Java里面线程池的顶级接口是Executor，但是严格意义上讲Executor并不是一个线程池，而是执行线程的工具。真正的线程池接口是ExecutorService newCachedThreadPool 调用executor将重用以前构造的线程（如果线程可用）。如果线程中没有可用的，则创建一个新线程并添加到池中。终止从缓存中移除那些已有60秒钟未被使用的线程 newFixedThreadPool 创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程 newScheduledThreadPool 创建一个线程池，它可在给定延迟后运行命令或者定期地执行 ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(3); scheduledThreadPool.schedule(new Runnable() { @Override public void run() { System.out.println(\"延时3秒\"); } },3, TimeUnit.SECONDS); scheduledThreadPool.scheduleAtFixedRate(new Runnable() { @Override public void run() { System.out.println(\"延迟1秒后每三秒执行1次\"); } },1,3,TimeUnit.SECONDS); newSingleThreadExecutor Executors.newSingleThreadExecutor()返回要给线程池，这个线程池只有线程。这个线程池可以在线程死后（或发生异常）重启一个线程来替代原来的线程继续执行下去 线程生命周期（状态） 新建状态 使用new关键词创建一个线程后，处于新建状态，仅由JVM为其分配内存，并初始化其成员变量 就绪状态 线程对象调用了start()方法之后。Java虚拟机会为其创建方法调用栈和程序计数器，等待调度运行 运行状态 就绪状态的线程获得了cpu，开始执行run()方法的线程执行体 阻塞状态 由于某种原因放弃了cpu使用权 分三种情况 等待阻塞：执行wait()方法 同步阻塞：获取对象同步锁时，同步锁被其他线程占用，JVM会把该线程放入锁池中 其他阻塞：执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求 线程死亡 线程会以三种方式结束，结束后就是死亡状态 正常结束：run()或call()方法执行完成 异常结束：线程抛出一个未捕获的Exception或Error 调用stop：直接调用线程的stop()方法来结束改线程——容易造成死锁，不推荐 sleep与wait区别 sleep()方法属于Thread类；wait()方法属于Object类 sleep()方法让出指定时间的cpu给其他线程，到时间之后自动恢复运行 调用sleep()方法的过程中，线程不会释放对象锁 调用wait()方法时，线程会放弃对象锁，进入等待此对象的等待锁定池，需要调用针对此对象的notify()方法后才会进入运行状态 start与run区别 start()方法用来启动线程，真正实现了多线程运行。无需等待run()方法执行完毕，可以直接继续执行下面的代码 调用Thread类的start()方法来启动一个线程，此线程进入就绪状态 方法run()称为线程体，包含要执行的这个线程的内容，线程就进入了运行状态，开始运行run函数当中的代码 Java锁 乐观锁 认为读多写少。 Java中基本都是通过CAS操作实现，CAS是一种更新的原子操作，比较当前值跟传入值是否一样，一样就更新，否则失效 悲观锁 认为写多 Java中的悲观锁是Synchronized，AQS框架下的锁则是先尝试cas乐观锁去获取锁，获取不到才会转换为悲观锁 自旋锁 volatile关键词 变量可见性 有volatile修饰的共享变量在写操作时，会多一行带有Lock前缀的汇编代码 Lock前缀的指令在多核处理器下会引发两件事 将当前处理器缓存行的数据写回到系统内存 这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效 缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是否过期，若发现已被修改，则会将缓存行设置为无效状态，处理器进行修改操作时，会重新从系统内存中读取数据到缓存 缓存行：缓存中可以分配的最小存储单位 禁止重排序 Synchronized的实现原理 对于同步方法，锁是当前实例对象 对于静态同步方法，锁是当前类的Class对象 对于同步代码块，锁是Synchronized括号里配置的对象 JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，代码块的同步是使用monitorenter和monitorexit指令实现 Java对象头 synchronized用的锁存在Java对象头里面 锁升级 无锁状态 偏向锁状态 优点：加锁解锁不需要额外消耗，速度快 缺点：如果线程存在锁竞争，会带来额外的锁撤销的消耗 适用场景：只有一个线程访问同步代码块 轻量级锁状态 优点：竞争的线程不会阻塞，提高程序响应速度 缺点：始终得不到锁竞争的线程，使用自旋会消耗CPU 适用场景：追求响应时间，同步块执行速度非常快 重量级锁状态 优点：线程竞争不使用自旋 缺点：线程阻塞，响应时间缓慢 适用场景：追求吞吐量，同步块执行时间较长 可以升级不能降级 在两个线程之间共享数据 将数据抽象成一个类，并将数据的操作作为这个类的方法 要在方法上加synchronized public class MyData { private int j = 0; public synchronized void add(){ j++; System.out.println(\"线程\"+Thread.currentThread().getName()+\"j为：\"+j); } public synchronized void dec(){ j--; System.out.println(\"线程\"+Thread.currentThread().getName()+\"j为：\"+j); } public int getData(){ return j; } } public class AddRunnable implements Runnable{ MyData data; public AddRunnable(MyData data){ this.data=data; } @Override public void run() { data.add(); } } public class DecRunnable implements Runnable { MyData data; public DecRunnable(MyData data){ this.data=data; } @Override public void run() { data.dec(); } } public static void main(String[] args) { MyData data = new MyData(); Runnable add = new AddRunnable(data); Runnable dec = new DecRunnable(data); for (int i = 0; i Runnable对象作为一个类的内部类 public class MyData { private int j = 0; public synchronized void add() { j++; System.out.println(\"线程\" + Thread.currentThread().getName() + \"j为：\" + j); } public synchronized void dec() { j--; System.out.println(\"线程\" + Thread.currentThread().getName() + \"j为：\" + j); } public int getData() { return j; } } class TestThread { public static void main(String[] args) { final MyData data = new MyData(); for (int i = 0; i "},"学习java/Java爬虫.html":{"url":"学习java/Java爬虫.html","title":"Java爬虫","keywords":"","body":"Jsoup 方式提取信息 学习链接 Jsoup 的依赖 org.jsoup jsoup 1.12.1 在列表页中，我们利用 F12 审查元素查看页面结构，经过我们分析发现列表新闻在 ‘’标签下，每一条新闻都是一个li标签 结合浏览器的 Copy 功能，编写出我们 a标签的 css 选择器代码：div.news-list > ul > li > div.list-hd > h4 > a /** * jsoup方式 获取虎扑新闻列表页 * @param url 虎扑新闻列表页url */ public void jsoupList(String url){ try { Document document = Jsoup.connect(url).get(); // 使用 css选择器 提取列表新闻 a 标签 // 霍华德：夏休期内曾节食30天，这考验了我的身心 Elements elements = document.select(\"div.news-list > ul > li > div.list-hd > h4 > a\"); for (Element element:elements){ // System.out.println(element); // 获取详情页链接 String d_url = element.attr(\"href\"); // 获取标题 String title = element.ownText(); System.out.println(\"详情页链接：\"+d_url+\" ,详情页标题：\"+title); } } catch (IOException e) { e.printStackTrace(); } } public static void main(String[] args) { String url = \"https://voice.hupu.com/nba\"; CrawlerBase crawlerBase = new CrawlerBase(); crawlerBase.jsoupList(url); } httpclient + 正则表达式 httpclient + 正则表达式的方式涉及的知识点还是蛮多的，正则表达式、Java 正则表达式、httpclient 依赖 org.apache.httpcomponents httpclient 4.5.10 org.apache.httpcomponents httpcore 4.4.10 org.apache.httpcomponents httpmime 4.5.10 我们需要找到能够代表列表新闻的结构体，比如： 直上云霄！魔术官方社媒晒富尔茨扣篮炫酷特效图这段结构体，每个列表新闻只有链接和标题不一样，其他的都一样，而且 是列表新闻特有的。 最好不要直接正则匹配 a标签，因为 a标签在其他地方也有，这样我们就还需要做其他的处理，增加我们的难度。现在我们了解了正则结构体的选择，我们一起来看看 httpclient + 正则表达式方式提取的代码： /** * httpclient + 正则表达式 获取虎扑新闻列表页 * @param url 虎扑新闻列表页url */ public void httpClientList(String url){ try { CloseableHttpClient httpclient = HttpClients.createDefault(); HttpGet httpGet = new HttpGet(url); CloseableHttpResponse response = httpclient.execute(httpGet); if (response.getStatusLine().getStatusCode() == 200) { HttpEntity entity = response.getEntity(); String body = EntityUtils.toString(entity,\"utf-8\"); if (body!=null) { /* * 替换掉换行符、制表符、回车符，去掉这些符号，正则表示写起来更简单一些 * 只有空格符号和其他正常字体 */ Pattern p = Pattern.compile(\"\\t|\\r|\\n\"); Matcher m = p.matcher(body); body = m.replaceAll(\"\"); /* * 提取列表页的正则表达式 * 去除换行符之后的 li * 与球迷亲切互动！凯尔特人官方晒球队开放训练日照片 */ Pattern pattern = Pattern .compile(\"\\\\s* \\\\s* (.*?)\\\\s* \\\\s* \" ); Matcher matcher = pattern.matcher(body); // 匹配出所有符合正则表达式的数据 while (matcher.find()){ // String info = matcher.group(0); // System.out.println(info); // 提取出链接和标题 System.out.println(\"详情页链接：\"+matcher.group(1)+\" ,详情页标题：\"+matcher.group(2)); } }else { System.out.println(\"处理失败！！！获取正文内容为空\"); } } else { System.out.println(\"处理失败！！！返回状态码：\" + response.getStatusLine().getStatusCode()); } }catch (Exception e){ e.printStackTrace(); } } public static void main(String[] args) { String url = \"https://voice.hupu.com/nba\"; CrawlerBase crawlerBase = new CrawlerBase(); // crawlerBase.jsoupList(url); crawlerBase.httpClientList(url); } "},"学习java/Java集合.html":{"url":"学习java/Java集合.html","title":"Java集合","keywords":"","body":"Java集合 集合类存放于Java.util包中，主要有三种set,list,map Collection：Collection是集合List，Set，Queue的最基本的接口 Iterator：迭代器，可以通过迭代器遍历集合中的数据 Map：是映射表的基础接口 List List是有序的Collection，有三个实现类：ArrayList，Vector，LinkList ArrayList（数组） 适合查找遍历，不适合插入删除 Vector（数组实现，线程同步） 某一时刻只有一个线程能够写Vector LinkList（链表） 链式结构，适合数据的动态插入和删除 Set 注重独一无二的性质，值不能重复 对象的相等性本质是对象hashCode值判断，如果想让两个不同对象视为相等，就必须覆盖Object的hashCode方法和equals方法 hashSet（Hash表） 按照哈希值来存的所以取数据也是按照哈希值取得。元素的哈希值通过元素的hashcode方法来获取 HashSet首先判断两个元素的哈希值，如果一样，接着回比较equals方法，结构为true则视为同一元素，否则不是 TreeSet（二叉树） Integer和String对象都可以进行默认的TreeSet排序，而定义类的对象是不可以的。自定义类必须实现Comparable接口，并覆写相应CompareTo()函数 LinkHashSet（HashSet+LinkedHashMap） 继承于HashSet，基于LinkedHashMap来实现 Map HashMap（数组+链表+红黑树） 非线程安全，即同一时刻可以有多个线程同时写HashMap，导致数据的不一致性 如果要满足线程安全，可以用Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者用ConcurrentHashMap 大方向上，HashMap是一个数组，数组的每个元素是一个单向链表 在Java8中，链表元素超过8个以后，会将链表转换为红黑树，降低查找的时间复杂度O(logN) CurrentHashMap 线程安全 HashTale（线程安全） TreeMap（可排序） LinkHashMap（记录插入顺序） 是HashMap的一个子类 "},"学习java/java常用类.html":{"url":"学习java/java常用类.html","title":"Java常用类","keywords":"","body":"String和StringBuffer的区别 String: 是对象不是原始类型。 为==不可变对象==,一旦被创建,就不能修改它的值。 对于已经存在的String对象的修改都是重新创建一个新的对象,然后把新的值保存进去。 String是final类,即不能被继承。 StringBuffer: 是一个==可变对象==,当对它进行修改的时候不会像String那样重新建立对象。 它只能通过构造函数来建立，StringBuffer subffer=new StringBuffer(); 对象被建立以后,在内存中就会分配内存空间,并初始保存一个null,通过它的append方法向其赋值 subffer.append(“hello word”); 字符串连接操作中StringBuffer的效率要明显比String高; String对象是不可变对象,每次操作String都会建立新的对象来保存新的值。 StringBuffer对象实例化后,只对这一个对象操作。 常用类和方法 一 Object类 1.1 toString() 主要用途：重写这个方法可以自定义对象输出格式（默认格式 ：类名 + @ +哈希码值） 1.2 equals() 主要用途 : 判断两个对象是否相同，默认的是比较两个对象的内存地址，一般重写equals方法的时候也会重写hasCode方法 1.3 hasCode() 主要用途 : 获取类的哈希码值，哈希码值相当于是类的内存地址 二 String类和StringBuffer 2.1 String类 2.1.1 字节数组构建字符串 String(byte[] bytes) 2.1.2 字符数组构建字符串 String(char[] value) 2.1.3 获取的方法 int length() //获取字符串长度 char charAt(int index) //获取特定位置的字符 int indexOf(String str) //获取字符的位置 2.1.4 判断方法 boolean endsWith(String str) //是否以指定的字符结尾 boolean isEmpty() //是否为空 boolean contains(Char Sequences) //是否包含指定的内容 boolean equalsIgnoreCase(String anotherString)//忽略大小写是否相等 2.1.5 转换方法 char[] toCharArray() //将字符串转换为字符数组 byte[] getBytes() //将字符串转换为字节数组 2.1.6 其他方法 String[] split(String regex) //分割字符串的方法 String substring(int beginIndex) //截取字符串的方法 String toUpperCase() //转大写 String trim() //去除字符串首尾空格 2.2 StringBuffer 与 StringBuilder StringBuffer和StringBuilder主要用于对字符串频繁增删改查的情况 2.2.1 添加的方法 append() //添加字符 insert(int offset,b) //插入索引值，插入的内容 2.2.2 删除的方法 delete(int start, int end) //根据指定的开始与结束的索引值删除对应的内容 deleteCharAt(int index) //根据指定的索引删除一个字符 2.2.3 修改 replace(int start, int end , String str) //把指定索引值的字符替换为指定的字符 reverse() // 反转字符串 2.2.4 查看 indexOf(String str, int fromIdnex) // 查找指定的字符串第一次出现的索引值，并且指定开始查找的位置 2.2.5 StringBuffer 与 StringBuilder(常用) 的相同与不同 相同： 1.两个类都是字符串缓冲类 2.两个类的方法都一样 不同: 1.StringBuffer是线程安全的，操作效率低，StringBuilder是线程非安全的,操作效率高 2.StringBuffer是jdk1.0出现的, StringBuilder 是jdk1.5的时候出现的. 三 System 和 RunTime类 3.1 System类 3.1.1 System常用方法 currentTimeMillis() //获取当前系统时间 exit(int status) //退出jvm gc() //建议jvm启动垃圾回收机制 getProperties();//获取系统的所有属性 3.2 RunTime类 3.2.1 RunTime常用方法 getRuntime(); // 返回当前应用程序的运行环境对象 exec(String command) //根据指定的路径执行对应的可执行文件 freeMemory() //获取jvm的空闲内存,以字节为单位 totalMemory() //返回jvm的内存总量 四 日期类 4.1 Calendar类 Calendar calendar = getInstance(); //获取当前的系统时间类 calendar.get(Calendar.YEAR)//获取年份 calendar.get(Calendar.MONTH)+1 //获取月份 calendar.get(Calendar.HOUR_OF_DAY） //获取小时,24小时制 4.2 SimpleDateFormat类(常用) 4.2.1 把日期转换成指定格式的字符串 Date date = new Date();//获取当前的系统时间 SimpleDateFormat simpleFormat = new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm:ss\");//设置格式化模式 String time = simpleFormat.format(date); 4.2.2 把字符串转换为对应的日期 SimpleDateFormat simpleFormat = new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm:ss\"); String birthday = \"2000年12月26日 11:29:08\"; Date date = simpleFormat.parse(birthday);//注意:指定的字符串格式必须要与SimpleDateFormat模式一至 五 Math类 5.1常用的方法 abs(double a) //获取绝对值 Math.abs(-3) ceil(double a) //向上取整 floor(double a) //向下取整 round(float a) //四舍五入 5.2 随机数类(Random) Random random = new Random(); int num = random.nextInt(10); //产生0-10之间的随机数 六 Scanner类 重点讲一下next()和nextLine()的区别 next() 只读取输入直到空格。它不能读两个由空格或符号隔开的单词。此外，next()在读取输入后将光标放在同一行中。(next()只读空格之前的数据,并且光标指向本行) nextLine() 读取输入，包括单词之间的空格和除回车以外的所有符号(即。它读到行尾)。读取输入后，nextLine()将光标定位在下一行。 演示1 public class Text { public static void main(String []args) { Scanner input = new Scanner(System.in); System.out.println(\"请输入一个字符串(中间能加空格或符号)\"); String a = input.nextLine(); System.out.println(\"请输入一个字符串(中间不能加空格或符号)\"); String b = input.next(); System.out.println(\"请输入一个整数\"); int c; c = input.nextInt(); System.out.println(\"请输入一个double类型的小数\"); double d = input.nextDouble(); System.out.println(\"请输入一个float类型的小数\"); float f = input.nextFloat(); System.out.println(\"按顺序输出abcdf的值：\"); System.out.println(a); System.out.println(b); System.out.println(c); System.out.println(d); System.out.println(f); } } 结果 请输入一个字符串(中间能加空格或符号) 我爱祖国！ 请输入一个字符串(中间不能加空格或符号) ILoveChina 请输入一个整数 520 请输入一个double类型的小数 12.26e3 请输入一个float类型的小数 3.1415926 按顺序输出abcdf的值： 我爱祖国！ ILoveChina 520 12260.0 3.1415925 演示2 public static void main(String[] args) { Scanner scan = new Scanner(System.in); //构造Scanner类的对象scan，接收从控制台输入的信息 System.out.println(\"请输入你的姓名\"); String name = scan.nextLine();//接收一个字符串，可以加除Enter以外的所有符号，包括空格和Tab System.out.println(\"请输入你的ID\"); String ID ; while(scan.hasNextLine()) {// hasNextLine()方法判断当前是否有输入，当键盘有输入后执行循环 if(scan.hasNextInt()) {// 判断输入的值是否为整数类型，当为整数类型时执行循环 ID = String.valueOf(scan.nextInt()); System.out.println(\"你输入的姓名为：\"+name); System.out.println(\"你输入的ID为：\"+ID); break; }else { System.out.println(\"请输入数字哦！\"); ID = String.valueOf(scan.nextInt()); } } } 结果 请输入你的姓名 西地那非 请输入你的ID q764323221 请输入数字哦！ 764323221 "},"学习java/jvm.html":{"url":"学习java/jvm.html","title":"Jvm","keywords":"","body":"JVM 可运行Java代码的假想计算机 包括一套字节码指令集，一组寄存器，一个栈，一个垃圾回收，堆和一个存储方法域 JVM运行在操作系统之上，与硬件没有直接的交互 Java跨平台的原因： ​ ①Java源文件→编译器→字节码文件 ​ ②字节码文件→JVM→机器码 每一种平台的解释器是不同的但是实现的虚拟机是相同的 JVM内存区域 线程私有 程序计数器PC 虚拟机栈VMStack 本地方法栈 线程共享 方法区（永久代） 类实例区（Java堆） 直接内存 程序计数器（线程私有） 当前线程所执行的字节码的行号指示器 在虚拟机中唯一一个没有规定任何OutOfMemoryError情况的区域 虚拟机栈（线程私有） 描述Java方法执行的内存模型 每个方法在执行的同时会创建出一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等 本地方法区（线程私有） 本地方法栈为Native方法服务 堆（Heap-线程共享）-运行时数据区 创建的对象和数组都保存在Java堆内存中，也是垃圾收集器进行垃圾收集最重要的内存区域 可细分为新生代和老年代 方法区/永久区 存储被JVM加载的类信息、常量、静态变量、即时编译器编译后的代码 包括运行时常量池 垃圾回收与算法 CMS 三色标记 黑：标记完成 白：没有遍历 灰：孩子还没有标记 G1 SATB Snapshot At the Beginning ZGC Colored Pointers Java四种引用类型 强引用 软引用 弱引用 虚引用 Java IO/NIO IO面向流，NIO面向缓冲区 JVM类加载器 分为5个部分：加载，验证，准备，解析，初始化 加载 在内存区中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的入口 验证 确保class文件的字节流中包含的信息是否符合当前虚拟机的要求 准备 在方法区中分配这些变量所使用的内存空间 public static int v = 8080;//变量v在准备阶段后的初始值为0而不是8080，赋值是在程序编译后，存放于类构造器中 public static final int v = 8080;//在编译阶段会为v生成ConstantValue属性，准备阶段根据ConstantValue属性将v赋值为8080 解析 虚拟机将常量池中的符号引用替换为直接引用的过程 符号引用： CONSTANT_Class_info CONSTANT_Field_info CONSTANT_Method_info 符号引用 直接引用 初始化 开始真正执行类中定义的Java程序代码 类构造器 初始化阶段执行类构造器方法的过程 如果一个类中没有静态变量赋值，也没有静态语句块，那么编译器可以不为这个类生成()方法 类加载器 启动类加载器 扩展类加载器 应用程序类加载器 调优 HotSpot参数分类 标准：- 开头，所有HotSpot都支持 非标准： -X 开头，特定版本HotSpot支持特定指令 不稳定：-XX 开头，下个版本可能取消 arthas工具 "},"学习java/noifelse.html":{"url":"学习java/noifelse.html","title":"Noifelse","keywords":"","body":"一般来说我们正常的后台管理系统都有所谓的角色的概念 不同管理员权限不一样，能够行使的操作也不一样 比如： 系统管理员（ROLE_ROOT_ADMIN）：有A操作权限 订单管理员（ROLE_ORDER_ADMIN）：有B操作权限 普通用户（ROLE_NORMAL）：有C操作权限 比如一个用户进来，我们需要根据不同用户的角色来判断其有哪些行为，这时候SAO代码出现了： if/else写法 public class JudgeRole { public String judge(String roleName) { String result = \"\"; if (roleName.equals(\"ROLE_ROOT_ADMIN\")) { // 系统管理员有A权限 result = \"ROLE_ROOT_ADMIN: \" + \"has AAA permission\"; } else if (roleName.equals(\"ROLE_ORDER_ADMIN\")) { // 订单管理员有B权限 result = \"ROLE_ORDER_ADMIN: \" + \"has BBB permission\"; } else if (roleName.equals(\"ROLE_NORMAL\")) { // 普通用户有C权限 result = \"ROLE_NORMAL: \" + \"has CCC permission\"; } else { result = \"XXX\"; } return result; } } ​ 这样当系统里有几十个角色时，那几十个 if/else嵌套可以说是非常酸爽了…… 这样一来非常不优雅，别人阅读起来很费劲；二来则是以后如果再复杂一点，或者想要再加条件的话不好扩展；而且代码一改，以前的老功能肯定还得重测，岂不疯了…… 使用枚举类 首先定义一个公用接口 RoleOperation，表示不同角色所能做的操作： public interface RoleOperation { String op();//表示某个角色可以做哪些操作 } 接下来我们将不同角色的情况全部交由枚举类来做，定义一个不同角色有不同权限的枚举类 RoleEnum： public enum RoleEnum implements RoleOperation { // 系统管理员(有A操作权限) ROLE_ROOT_ADMIN { @Override public String op() { return \"ROLE_ROOT_ADMIN:\" + \" has AAA permission\"; } }, // 订单管理员(有B操作权限) ROLE_ORDER_ADMIN { @Override public String op() { return \"ROLE_ORDER_ADMIN:\" + \" has BBB permission\"; } }, // 普通用户(有C操作权限) ROLE_NORMAL { @Override public String op() { return \"ROLE_NORMAL:\" + \" has CCC permission\"; } }; } 接下来调用就变得异常简单了，一行代码就行了， if/else也灰飞烟灭了： public class JudgeRoleByEnum { public String judge(String roleName) { // 一行代码搞定！之前的if/else没了！ return RoleEnum.valueOf(roleName).op(); } } 而且这样一来，以后假如我想扩充条件，只需要去枚举类中加代码即可，而不是去改以前的代码，这岂不很稳！ 工厂模式 需要上面定义的接口 首先，针对不同的角色，单独定义其业务类： // 系统管理员(有A操作权限) public class RootAdminRole implements RoleOperation { private String roleName; public RootAdminRole(String roleName ){ this.roleName = roleName; } @Override public String op() { return roleName +\" has AAA permission\"; } } // 订单管理员(有B操作权限) public class OrderAdminRole implements RoleOperation { private String roleName; public OrderAdminRole(String roleName ){ this.roleName = roleName; } @Override public String op() { return roleName +\" has BBB permission\"; } } // 普通用户(有C操作权限) public class NormalRole implements RoleOperation { private String roleName; public NormalRole(String roleName ){ this.roleName = roleName; } @Override public String op() { return roleName +\" has CCC permission\"; } } 接下来再写一个工厂类 RoleFactory对上面不同角色进行聚合： public class RoleFactory { static Map roleOperationMap = new HashMap<>(); //在静态块中先把初始化工作全部做完 static { roleOperationMap.put(\"ROLE_ROOT_ADMIN\",new RootAdminRole(\"ROLE_ROOT_ADMIN\")); roleOperationMap.put(\"ROLE_ORDER_ADMIN\",new RootAdminRole(\"ROLE_ORDER_ADMIN\")); roleOperationMap.put(\"ROLE_NORMAL\",new RootAdminRole(\"ROLE_NORMAL\")); } public static RoleOperation getOp(String roleName){ return roleOperationMap.get(roleName); } } 接下来借助上面这个工厂，业务代码调用也只需一行代码， if/else同样被消除了 public class JudgeRoleByFactory { public String judge(String roleName){ //1行代码搞定！之前的if/else也没了! return RoleFactory.getOp(roleName).op(); } } 这样的话以后想扩展条件也很容易，只需要增加新代码，而不需要动以前的业务代码，非常符合“开闭原则”。 策略模式 在上面工厂模式代码的基础上(需要接口) 按照策略模式的指导思想，我们也来创建一个所谓的策略上下文类，这里命名为 RoleContext： public class RoleContext { //可更换的策略，传入不同的策略对象，业务即相应变化 private RoleOperation operation; public RoleContext(RoleOperation operation){ this.operation=operation; } public String execute(){ return operation.op(); } } 很明显上面传入的参数 operation就是表示不同的“策略”。我们在业务代码里传入不同的角色，即可得到不同的操作结果： public class JudgeRoleByContext { public String judge(RoleOperation roleOperation){ RoleContext roleContext = new RoleContext(roleOperation); return roleContext.execute(); } } public static void main(String[] args) { JudgeRoleByContext judgeRoleByContext = new JudgeRoleByContext(); String result1 = judgeRoleByContext.judge(new RootAdminRole(\"ROLE_ROOT_ADMIN\")); System.out.println(result1); String result2 = judgeRoleByContext.judge(new OrderAdminRole(\"ROLE_ORDER_ADMIN\")); System.out.println(result2); String result3 = judgeRoleByContext.judge(new NormalRole(\"ROLE_NORMAL\")); System.out.println(result3); } "},"学习java/socket.html":{"url":"学习java/socket.html","title":"Socket","keywords":"","body":"与网络调试助手通信 问题1：网络调试助手作为客户端，发送消息后，客户端未收到 原因：readLine（）这个方法本身有一个注意点，它读取的是一整行，遇见‘\\n’或 ‘ \\r’ 代表读取结束。因为用的是网络助手作为客户端 ，每次发送消息时并不会添加‘\\n’，而用控制台作为客户端进行发送时，按下回车的时候就已经添加了‘\\n’，所以服务器端进行接收的时候就是实时显示的。 互相发送信息，互相接收，每次一条 服务器端代码 import java.io.BufferedReader; import java.io.InputStreamReader; import java.io.PrintWriter; import java.net.ServerSocket; import java.net.Socket; public class SocketServer { //搭建服务器端 public static void main(String[] args) { //1、a)创建一个服务器端Socket，即SocketService SocketServer socketService = new SocketServer(); socketService.oneServer(); } private void oneServer(){ try{ ServerSocket server=null; try{ //下面是端口，端口可以和客户端代码里面的端口一样 server=new ServerSocket(5209); //b)指定绑定的端口，并监听此端口。 System.out.println(\"服务器启动成功\"); //创建一个ServerSocket在端口5209监听客户请求 }catch(Exception e) { System.out.println(\"没有启动监听：\"+e); //出错，打印出错信息 } Socket socket=null; try{ socket=server.accept(); //2、调用accept()方法开始监听，等待客户端的连接 //使用accept()阻塞等待客户请求，有客户 //请求到来则产生一个Socket对象，并继续执行 }catch(Exception e) { System.out.println(\"Error.\"+e); //出错，打印出错信息 } //3、获取输入流，并读取客户端信息 String line; BufferedReader in=new BufferedReader(new InputStreamReader(socket.getInputStream())); //由Socket对象得到输入流，并构造相应的BufferedReader对象 PrintWriter writer=new PrintWriter(socket.getOutputStream()); //由Socket对象得到输出流，并构造PrintWriter对象 BufferedReader br=new BufferedReader(new InputStreamReader(System.in)); //由系统标准输入设备构造BufferedReader对象 System.out.println(\"Client:\"+in.readLine()); //在标准输出上打印从客户端读入的字符串 line=br.readLine(); //从标准输入读入一字符串 //4、获取输出流，响应客户端的请求 while(!line.equals(\"end\")){ //如果该字符串为 \"bye\"，则停止循环 writer.println(line); //向客户端输出该字符串 writer.flush(); //刷新输出流，使Client马上收到该字符串 System.out.println(\"服务:\"+line); //在系统标准输出上打印读入的字符串 System.out.println(\"客户:\"+in.readLine()); //从Client读入一字符串，并打印到标准输出上 line=br.readLine(); //从系统标准输入读入一字符串 } //继续循环 //5、关闭资源 writer.close(); //关闭Socket输出流 in.close(); //关闭Socket输入流 socket.close(); //关闭Socket server.close(); //关闭ServerSocket }catch(Exception e) {//出错，打印出错信息 System.out.println(\"Error.\"+e); } } } 客户端代码 import java.io.BufferedReader; import java.io.InputStreamReader; import java.io.PrintWriter; import java.net.Socket; public class SocketClient { // 搭建客户端 public static void main(String[] args) { try { // 1、创建客户端Socket，指定服务器地址和端口 //下面是你要传输到另一台电脑的IP地址和端口 Socket socket = new Socket(\"127.0.0.1\", 5209); System.out.println(\"客户端启动成功\"); // 2、获取输出流，向服务器端发送信息 // 向本机的52000端口发出客户请求 BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); // 由系统标准输入设备构造BufferedReader对象 PrintWriter write = new PrintWriter(socket.getOutputStream()); // 由Socket对象得到输出流，并构造PrintWriter对象 //3、获取输入流，并读取服务器端的响应信息 BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream())); // 由Socket对象得到输入流，并构造相应的BufferedReader对象 String readline; readline = br.readLine(); // 从系统标准输入读入一字符串 while (!readline.equals(\"end\")) { // 若从标准输入读入的字符串为 \"end\"则停止循环 write.println(readline); // 将从系统标准输入读入的字符串输出到Server write.flush(); // 刷新输出流，使Server马上收到该字符串 System.out.println(\"客户:\" + readline); // 在系统标准输出上打印读入的字符串 System.out.println(\"服务:\" + in.readLine()); // 从Server读入一字符串，并打印到标准输出上 readline = br.readLine(); // 从系统标准输入读入一字符串 } // 继续循环 //4、关闭资源 write.close(); // 关闭Socket输出流 in.close(); // 关闭Socket输入流 socket.close(); // 关闭Socket } catch (Exception e) { System.out.println(\"can not listen to:\" + e);// 出错，打印出错信息 } } } 服务器端持续接收信息，并返回客户端以及写好的信息 import java.io.BufferedReader; import java.io.BufferedWriter; import java.io.IOException; import java.io.InputStreamReader; import java.io.OutputStreamWriter; import java.net.ServerSocket; import java.net.Socket; import java.util.Date; public class SocketServerContinue { private BufferedWriter writer; private BufferedReader reader; public static void main(String[] args) { SocketServerContinue socketServer = new SocketServerContinue(); socketServer.startServer(); } private void startServer() { ServerSocket serverSocket = null; Socket socket = null; try { // 端口号只要不冲突就行 serverSocket = new ServerSocket(9898); System.out.println(\"server started..\"); while (true) { // 进入阻塞状态，等待客户端接入 socket = serverSocket.accept(); manageConnection(socket); } } catch (Exception e) { e.printStackTrace(); } finally { try { assert socket != null; socket.close(); serverSocket.close(); } catch (IOException e) { e.printStackTrace(); } } } private void manageConnection(final Socket socket) { new Thread(() -> { try { System.out.println(\"client \" + socket.hashCode() + \" connected\"); // 从socket中读取数据 reader = new BufferedReader(new InputStreamReader(socket.getInputStream())); writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())); String receiveMsg; while ((receiveMsg = reader.readLine()) != null) { // 以\"\\n\"结束 System.out.println(\"client \" + socket.hashCode() + \":\" + receiveMsg); Person person = new Person(); person.setBirthday(new Date()); person.setClassId(\"B170404\"); person.setId(\"B17040417\"); person.setName(\"yll\"); writer.write(\"server reply:\" + person.toString() + \"\\n\"); writer.flush(); } } catch (IOException e) { e.printStackTrace(); } finally { try { reader.close(); writer.close(); } catch (IOException e) { e.printStackTrace(); } } }).start(); } } "},"学习java/一些Java方法.html":{"url":"学习java/一些Java方法.html","title":"一些Java方法","keywords":"","body":"数组复制 int[] array = {1,5,7,4,8}; int[] b = Arrays.copyOfRange(array,1,9); int[] cc = new int[array.length]; System.arraycopy(array,0,cc,2,3); System.out.println(Arrays.toString(cc)); System.out.println(Arrays.toString(b)); //运行结果 //[0, 0, 1, 5, 7] //[5, 7, 4, 8, 0, 0, 0, 0] arraycopy() 方法 5个参数，原数组，原数组起始索引，目标数组，目标数组起始索引，长度 位于 java.lang.System 类中，其语法形式如下： System.arraycopy(dataType[] srcArray,int srcIndex,int destArray,int destIndex,int length) 其中，srcArray 表示原数组；srcIndex 表示原数组中的起始索引；destArray 表示目标数组；destIndex 表示目标数组中的起始索引；length 表示要复制的数组长度。 使用此方法复制数组时，length+srcIndex 必须小于等于 srcArray.length，同时 length+destIndex 必须小于等于 destArray.length。 CopyOfRange() 方法 根据起始索引和终止索引复制数组，传入3个参数 是另一种复制数组的方法，其语法形式如下： Arrays.copyOfRange(dataType[] srcArray,int startIndex,int endIndex) 其中： srcArray 表示原数组。 startIndex 表示开始复制的起始索引，目标数组中将包含起始索引对应的元素，另外，startIndex 必须在 0 到 srcArray.length 之间。 endIndex 表示终止索引，目标数组中将不包含终止索引对应的元素，endIndex 必须大于等于 startIndex，可以大于 srcArray.length，如果大于 srcArray.length，则目标数组中使用默认值填充。 Arrays.copyOf方法 传入2或3个参数，原数组，长度，数组类型 original - 要复制的数组 newLength - 要返回的副本的长度 newType - 要返回的副本的类型 其实Arrays.copyOf底层也是调用System.arraycopy实现的源码如下： //基本数据类型（其他类似byte，short···） public static int[] copyOf(int[] original, int newLength) { int[] copy = new int[newLength]; System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy; } "},"学习java/一些其他人写的博客.html":{"url":"学习java/一些其他人写的博客.html","title":"一些其他人写的博客","keywords":"","body":"Java关键词 native native 用来修饰方法，用 native 声明的方法表示告知 JVM 调用，该方法在外部定义，我们可以用任何语言去实现它。 简单地讲，一个native Method就是一个 Java 调用非 Java 代码的接口 native 语法： 修饰方法的位置必须在返回类型之前，和其余的方法控制符前后关系不受限制。 不能用 abstract 修饰，也没有方法体，也没有左右大括号。 返回值可以是任意类型 我们在日常编程中看到native修饰的方法，只需要知道这个方法的作用是什么，至于别的就不用管了，操作系统会给我们实现。 instanceof 严格来说是Java中的一个双目运算符，用来测试一个对象是否为一个类的实例 用法 boolean result = obj instanceof Class 其中 obj 为一个对象（obj必须为引用类型，不能是基本类型），Class 表示一个类或者一个接口，当 obj 为 Class 的对象，或者是其直接或间接子类，或者是其接口的实现类，结果result 都返回 true，否则返回false 浅拷贝与深拷贝 基本类型和引用类型 基本类型也称为值类型，分别是字符类型 char，布尔类型 boolean以及数值类型 byte、short、int、long、float、double。 引用类型则包括类、接口、数组、枚举等。 Java 将内存空间分为堆和栈。基本类型直接在栈中存储数值，而引用类型是将引用放在栈中，实际存储的值是放在堆中，通过栈中的引用指向堆中存放的数据。 浅拷贝 创建一个新对象，然后将当前对象的非静态字段复制到该新对象，如果字段是值类型的，那么对该字段执行复制；如果该字段是引用类型的话，则复制引用但不复制引用的对象。因此，原始对象及其副本引用同一个对象 深拷贝 创建一个新对象，然后将当前对象的非静态字段复制到该新对象，无论该字段是值类型的还是引用类型，都复制独立的一份。当你修改其中一个对象的任何内容时，都不会影响另一个对象的内容。 如何实现深拷贝 让每个引用类型属性内部都重写clone() 方法 利用序列化 序列化与反序列化 序列化 指把堆内存中的 Java 对象数据，通过某种方式把对象存储到磁盘文件中或者传递给其他网络节点（在网络上传输）。这个过程称为序列化。通俗来说就是将数据结构或对象转换成二进制串的过程 反序列化 把磁盘文件中的对象数据或者把网络节点上的对象数据，恢复成Java对象模型的过程。也就是将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程 JavaIO 字节输入输出流 字符输入输出流 为什么要使用字符流？ 　　因为使用字节流操作汉字或特殊符号语言的时候容易乱码，因为汉字不止一个字节，为了解决这个问题，建议使用字符流。 什么情况下使用字符流？ 　　一般可以用记事本打开的文件，我们可以看到内容不乱码的。就是文本文件，可以使用字符流。而操作二进制文件（比如图片、音频、视频）必须使用字节流 源码分析 ArrayList源码分析 扩容 当通过 ArrayList() 构造一个空集合，初始长度是为0的，第 1 次添加元素，会创建一个长度为10的数组，并将该元素赋值到数组的第一个位置。 长度超过10时，会扩容1.5倍 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) hugeCapacity() 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，如果minCapacity大于最大容量，则新容量则为Integer.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 Integer.MAX_VALUE - 8。 private static int hugeCapacity(int minCapacity) { if (minCapacity MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; } 第 Integer.MAX_VALUE + 1 次添加元素时，抛出 OutOfMemoryError 异常。 HashMap源码 loadFactor 　　负载因子表示一个散列表的空间的使用程度，有这样一个公式：initailCapacity*loadFactor=HashMap的容量 　　默认的负载因子0.75 是对空间和时间效率的一个平衡选择，建议大家不要修改，除非在时间和空间比较特殊的情况下，如果内存空间很多而又对时间效率要求很高，可以降低负载因子loadFactor 的值；相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子 loadFactor 的值，这个值可以大于1。 threshold 　　计算公式：capacity * loadFactor。这个值是当前已占用数组长度的最大值。size过这个数目就重新resize(扩容)，扩容后的 HashMap 容量是之前容量的两倍 HashMap中的hash算法 static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16); } i = (table.length - 1) & hash;//这一步是在后面添加元素putVal()方法中进行位置的确定 主要分为三步： 取 hashCode 值： key.hashCode() 高位参与运算：h>>>16 取模运算：(n-1) & hash 这里获取 hashCode() 方法的值是变量，但是我们知道，对于任意给定的对象，只要它的 hashCode() 返回值相同，那么程序调用 hash(Object key) 所计算得到的 hash码 值总是相同的。 　　为了让数组元素分布均匀，我们首先想到的是把获得的 hash码对数组长度取模运算( hash%length)，但是计算机都是二进制进行操作，取模运算相对开销还是很大的，那该如何优化呢？ 　　HashMap 使用的方法很巧妙，它通过 hash & (table.length -1)来得到该对象的保存位，前面说过 HashMap 底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当 length 总是2的n次方时，hash & (length-1)运算等价于对 length 取模，也就是 hash%length，但是&比%具有更高的效率。比如 n % 32 = n & (32 -1) 　　这也解释了为什么要保证数组的长度总是2的n次方。 hashCode() 得到的是一个32位 int 类型的值，通过hashCode()的高16位 异或 低16位实现的：(h = k.hashCode()) ^ (h >>> 16)。这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。 MySQL连接 内连接 关键字：inner join on 语句：select * from a_table a inner join b_table b on a.a_id = b.b_id; 说明：组合两个表中的记录，返回关联字段相符的记录，也就是返回两个表的交集（阴影）部分。 外连接 左连接 关键字：left join on / left outer join on 语句：SELECT * FROM a_table a left join b_table b ON a.a_id = b.b_id; 说明： left join 是left outer join的简写，它的全称是左外连接，是外连接中的一种。 左(外)连接，左表(a_table)的记录将会全部表示出来，而右表(b_table)只会显示符合搜索条件的记录。右表记录不足的地方均为NULL。 右连接 关键字：right join on / right outer join on 语句：SELECT * FROM a_table a right outer join b_table b on a.a_id = b.b_id; 说明：right join是right outer join的简写，它的全称是右外连接，是外连接中的一种。与左(外)连接相反，右(外)连接，左表(a_table)只会显示符合搜索条件的记录，而右表(b_table)的记录将会全部表示出来。左表记录不足的地方均为NULL。 "},"学习java/硬核空间.html":{"url":"学习java/硬核空间.html","title":"硬核空间","keywords":"","body":"一次给阿里巴巴fastjson修bug的学习经历 fastjson也是我最近有用到的一个开源库 这是我在B站学习到的，下面附上视频链接 视频链接 找bug标准 bug能复现 bug比较重要，也就是说很多人都出现过这个bug 找到bug 找到的bug：fastjson无法反序列化超出某种限制的类#2779 下面有bug链接 bug链接 首先使用git clone fastjson项目，在idea中打开 进入test包，发现java.alibaba.fastjson.deserializer包下已经有issue2779的测试类了 当然，这是up主已经修复的版本啦，我们运行发现并没有报错，哈哈哈 复现bug 所以我们使用git回退到up主还没修复成功的版本 他是11.4修复的，我们回退到下面的10.29 在此之前，我们可以先把issue2779包里面的两个文件在本地进行修改一下（按回车增加一行就可以），以免回退的时候这个包直接消失了 上图选错了，应该选择Keep→Reset 看后面的信息就可以知道，选择keep本地修改的文件（也就是刚才修改的issue2779包内的两个文件）会保存下来了，如果选hard就直接暴力删除啦 之后运行issue2779测试类，终于出现了报错信息 然后找这种jdk和这个项目报错信息的交界处 也就是com.alibaba.fastjson.parser.deserializer包下面的ASMDeserializerFactory类的createJavaBeanDeserializer方法有问题 查找问题 我们定位到这一行，进行断点调试 查看code变量 code是一个Java字节码 所有的.class 文件的前四个字节都是魔数，魔数的固定值为：0xCAFEBABE Java有咖啡的意思，程序员的浪漫~ 魔数的固定值是 Java 之父 James Gosling 制定的，为 CafeBabe（咖啡宝贝），而 Java 的图标为一杯咖啡 Evaluate Expression表达式求值 在code处右键有个Evaluate Expression，表达式求值 将字节码输出到文件bad.class 可以看到项目这里出现了bad.class文件 很奇怪，我这里idea居然还是可以反编译成功 如果是坏的，idea无法反编译，会出现下面的结果，视频中是这样的 我们可以用一些工具来查看这个坏的字节码文件 例如下面的命令 javap -v bad #Java自带的反编译工具 但是太长了，在命令行看也不太方便 我们使用下面的工具classpy 反编译工具classpy 在GitHub搜索classpy，clone下来，按照readme安装运行 我是Windows系统，首先进入classpy目录下，点击运行了gradlew.bat文件，然后在当前目录下的命令行输入下面的命令启动这个工具 gradle run 视频中他的Java版本为11，启动失败了 使用了jenv命令切换到jdk1.8，我使用的就是jdk1.8 忽略这个步骤 jenv shell 1.8 #需要安装jenv 下面是打开的字节码文件 由于我们只有Illegal target of jump or branch这个报错信息，这一个线索 下面buildjdk操作太硬核，我没有跟着做&#x1F602; 感兴趣可以去视频16:45处看看&#x1F44D; 到jdk中寻找此报错信息 clone openjdk下的jdk项目，全局搜索此报错信息Illegal target of jump or branch 然后他修改了jdk，上面图片中的代码就是修改后的jdk，原来只有报错信息，他自己加上了jump和target，可以提示错误的位置，如下图 然后他自己build了一个jdk&#x1F44D; 使用自己build的jdk重新运行issue2779，下面是报错信息，deserialze方法第50位置 在刚才classpy打开的bad.class中找到deserialze方法 字节码 第50个位置是这样的 ifeq -32405 可能是溢出 查看ifeq的含义，当栈顶int型数值等于0时跳转 fastjson有个地方代码没有写好，生成了一个会溢出的跳转指令 然后根据上下文(50位置上面有个isEnabled)，在源码中找到相应位置 进入visitJumpInsn方法，这其实是asm代码（操作字节码的库） 按crtl+alt+B可以进入接口的实现类 解决问题 然后他觉得，可能是fastjson里面的asm代码版本太老了，想把最新的合并进来，但是由于版本相差7年，失败了 对比最新的asm代码与fastjson里面的代码 这里非常重要，如果越界，可以将IFxxx改为IFNOTxxx GOTO_W 最后解决的问题：按照asm的要求，把一个不支持长跳转的ifeq转变成ifnq加goto_w长跳转语句 pr链接 修完bug一定要补一个测试用例！ 视频中提到其他内容 字节码的解释： 简单写一个测试一下 public class AbcDTO { public static void main(String [] args) { int i =1,j=2; if (i+j==3){ System.out.println(\"3\"); }else { System.out.println(\"0\"); } } 编译运行，使用ASM Bytecode Viewer插件查看字节码 ASM Bytecode Viewer插件 可在idea Plugins中安装 找到main方法 每个方法里面有个操作数栈，jvm执行方法时会不停的执行这些指令 修bug要掌握的东西 能从用户提供的bug，重现bug 看栈轨迹，字节码问题出在哪里 学习使用反编译工具 错误信息到底是什么问题，读jdk源码（甚至需要build jdk） R大的书单RednaxelaFX 下· mybatis需要掌握的内容 {} ${} 缓存是咋实现的？ Executor是啥？ 分页是怎么实现的？ 总结一下看这个视频了解到的内容 Java字节码的magic number Cofe Babe idea的表达式计算Evaluate Expression 学习使用反编译工具javap -v 、classpy ASM Bytecode Viewer插件查看字节码 话说我才刚知道idea中快捷键CTRL+Alt+B可以从接口跳转到实现类&#x1F602;然后Ctrl+U是实现类到接口&#x1F923; GitHub中的issue以及pull request 分析OOM问题 OOM代码 public class OOM { static class OOM{ } public static void main(String[] args) { List list = new ArrayList<>(); while (true){ list.add(new OOM()); } } } 编译运行 jps #获取Java进程号 20440 OOM jmap -dump:live,format=b,file=D:\\code\\java\\20440.hprof 20440 #获取快照 Dumping heap to D:\\code\\java\\20440.hprof ... Heap dump file created "},"学习java/遇到的问题.html":{"url":"学习java/遇到的问题.html","title":"遇到的问题","keywords":"","body":"加载配置文件失败的问题 package interview.designpattern.single;//包路径 public class AppConfig { private String paraA; private String paraB; public String getParaA() { return paraA; } public String getParaB() { return paraB; } public AppConfig() throws IOException { readConfig(); } private void readConfig() throws IOException { Properties p =new Properties(); InputStream in = null; in=AppConfig.class.getClassLoader().getResourceAsStream(\"Test.properties\"); p.load(in); this.paraA=p.getProperty(\"a\"); this.paraB=p.getProperty(\"b\"); in.close(); } public static void main(String[] args) throws IOException { AppConfig a = new AppConfig(); System.out.println(a.getParaA()); } } 在同一个包下创建配置文件Test.properties a=1 b=2 运行时总是报错，空指针异常 错误原因 简单修改代码 private void readConfig() throws IOException { Properties p =new Properties(); InputStream in = null; in=AppConfig.class.getClassLoader().getResourceAsStream(\"Test.properties\"); //增加下面3行代码 System.out.println(AppConfig.class.getResource(\"\").getPath()); System.out.println(AppConfig.class.getResource(\"/\").getPath()); System.out.println(AppConfig.class.getClassLoader().getResource(\"\").getPath()); p.load(in); this.paraA=p.getProperty(\"a\"); this.paraB=p.getProperty(\"b\"); in.close(); } 运行结果 /E:/Javacode/target/classes/interview/designpattern/single/ /E:/Javacode/target/classes/ /E:/Javacode/target/classes/ 可以看到，获取到的路径是在target文件夹，而properties文件并没有生成到target文件夹下 解决方案 我的解决方案，创建resource文件夹，将配置文件Test.properties放到resource里面 生成target文件夹时，配置文件会在target/classes里面 这样用 AppConfig.class.getClassLoader().getResourceAsStream(\"Test.properties\"); 就可以获取到了 "},"学习java/阻塞队列.html":{"url":"学习java/阻塞队列.html","title":"阻塞队列","keywords":"","body":"ArrayBlockingQueue add和remove方法 抛异常 public static void test1() { //队列的大小 ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue<>(3); System.out.println(blockingQueue.add(\"a\")); System.out.println(blockingQueue.add(\"b\")); System.out.println(blockingQueue.add(\"c\"));//输出true //超出容量，抛出异常java.lang.IllegalStateException: Queue full //System.out.println(blockingQueue.add(\"d\")); System.out.println(\"=================\"); System.out.println(blockingQueue.remove());//输出a System.out.println(blockingQueue.remove());//输出b System.out.println(blockingQueue.remove());//输出c //抛出异常java.util.NoSuchElementException //System.out.println(blockingQueue.remove()); } offer和poll方法 有返回值，没有异常 public static void test2() { //队列的大小 ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue<>(3); System.out.println(blockingQueue.offer(\"a\")); System.out.println(blockingQueue.offer(\"b\")); System.out.println(blockingQueue.offer(\"c\"));//输出true System.out.println(blockingQueue.offer(\"d\"));//没有异常，输出false System.out.println(\"=================\"); System.out.println(blockingQueue.poll());//输出a System.out.println(blockingQueue.poll());//输出b System.out.println(blockingQueue.poll());//输出c System.out.println(blockingQueue.poll());//没有异常，输出null } put和take方法 等待，阻塞 public static void test3() throws InterruptedException { //队列的大小 ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue<>(3); blockingQueue.put(\"a\"); blockingQueue.put(\"b\"); blockingQueue.put(\"c\"); //blockingQueue.put(\"d\");//队列没有位置了，一直阻塞 System.out.println(\"=================\"); System.out.println(blockingQueue.take());//输出a System.out.println(blockingQueue.take());//输出b System.out.println(blockingQueue.take());//输出c //System.out.println(blockingQueue.take());//没有这个元素，一直阻塞 } offer和poll方法 等待，阻塞(等待超时) public static void test4() throws InterruptedException { //队列的大小 ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue<>(3); blockingQueue.offer(\"a\"); blockingQueue.offer(\"b\"); blockingQueue.offer(\"c\"); blockingQueue.offer(\"d\", 2, TimeUnit.SECONDS);//等待超过两秒就退出 System.out.println(\"=================\"); System.out.println(blockingQueue.poll());//输出a System.out.println(blockingQueue.poll());//输出b System.out.println(blockingQueue.poll());//输出c System.out.println(blockingQueue.poll(2, TimeUnit.SECONDS));//等待超过两秒就退出 } SynchronousQueue 同步队列，没有容量。进去一个元素，必须取出来，才能往里放一个元素 public class SynchronousQueueTest { public static void main(String[] args) { BlockingQueue blockingDeque = new SynchronousQueue<>(); new Thread(() -> { try { System.out.println(Thread.currentThread().getName() + \" put 1\"); blockingDeque.put(\"1\"); System.out.println(Thread.currentThread().getName() + \" put 2\"); blockingDeque.put(\"2\"); System.out.println(Thread.currentThread().getName() + \" put 3\"); blockingDeque.put(\"3\"); } catch (InterruptedException e) { e.printStackTrace(); } }, \"T1\").start(); new Thread(() -> { try { TimeUnit.SECONDS.sleep(3); System.out.println(Thread.currentThread().getName() + \" take \" + blockingDeque.take()); TimeUnit.SECONDS.sleep(3); System.out.println(Thread.currentThread().getName() + \" take \" + blockingDeque.take()); TimeUnit.SECONDS.sleep(3); System.out.println(Thread.currentThread().getName() + \" take \" + blockingDeque.take()); } catch (InterruptedException e) { e.printStackTrace(); } }, \"T2\").start(); } } "},"安卓开发/":{"url":"安卓开发/","title":"安卓开发","keywords":"","body":"Introduction "},"安卓开发/First App.html":{"url":"安卓开发/First App.html","title":"First App","keywords":"","body":"创建一个Android app 主要项目结构 最重要的文件 首先，请确保已打开 Project 窗口（依次选择 View > Tool Windows > Project），并从该窗口顶部的下拉列表中选择 Android 视图。随后，您可以看到以下文件： app > java > com.example.myfirstapp > MainActivity 这是主 Activity（您的应用的入口点）。当您构建和运行应用时，系统会启动此 Activity 的实例并加载其布局。 app > res > layout > activity_main.xml 此 XML 文件定义 Activity 界面的布局。它包含带有文本“Hello world!”的 TextView 元素。 app > manifests > AndroidManifest.xml 清单文件描述应用的基本特性并定义其每个组件。 Gradle Scripts > build.gradle 您会看到两个具有此名称的文件：一个用于项目（“项目：MyFirstApp”），一个用于“app”模块（“模块：app”）。每个模块均有自己的 build.gradle 文件，但此项目当前仅有一个模块。您将主要使用模块的 build.gradle 文件来配置 Gradle 工具如何编译和构建您的应用。如需详细了解此文件，请参阅配置编译系统。 打开布局编辑器 首先，请按照以下步骤设置您的工作区： 在 Android Studio 的“Project”窗口中，打开 app > res > layout > activity_main.xml。 要给布局编辑器留出更多空间，请隐藏 Project 窗口，方法是依次选择 View > Tool Windows > Project（或点击 Android Studio 左侧的 Project 图标 ）。 如果您的编辑器显示 XML 源代码，请点击窗口底部的 Design 标签。 点击 Select Design Surface 图标 ，然后选择 Blueprint。 点击布局编辑器工具栏中的 Show 图标 ，并确保选中 Show Constraints。 确保 Autoconnect 处于关闭状态。工具栏中的提示应为 Turn On Autoconnect 图标 （因为它现在处于关闭状态）。 点击工具栏中的 Default Margins 图标 ，然后选择 16（您稍后仍然可以调整每个视图的外边距）。 点击工具栏中的 Device for Preview 图标 ，然后选择 5.5, 1440 × 2560, 560dpi (Pixel XL)。 您的编辑器现在应如图 3 所示。 "},"安卓开发/problems.html":{"url":"安卓开发/problems.html","title":"Problems","keywords":"","body":"不清楚两个读卡数据之间的关系 数据1：RFID *05958C94# 十位十进制数 2492241157 数据2：RFID *89FA709E# 十位十进制数 2658204297 2658204297 转16进制 9e 70 fa 89 厉害厉害 10进制转16进制之后按字节逆序读入 我来转回去 BigInteger s10 = new BigInteger(\"2492241157\",10); String s16 = s10.toString(16); StringBuilder to10 = new StringBuilder(); for (int i=s16.length()-1;i>=0;i-=2){ to10.append(s16.charAt(i-1)); to10.append(s16.charAt(i)); } System.out.println(\"十进制:\"+s10); System.out.println(\"十六进制:\"+s16); System.out.println(\"转换后:\"+to10); 出现BigInteger的格式错误，不知道为什么总是有个读空字符串转BigInteger 增加一个非空判断后问题解决 找到原因了，那个if语句后面没有大括号，是只跟了一条的。。。 BigInteger与int转换 //BigInteger与int转换 //int 转换为 BigInteger的方法： int p = 1; BigInteger a = BigInteger.valueOf(p); //BigInteger 转换为 int的方法： BigInteger d = new BigInteger(\"9\"); int temp = d.intValue(); String与int的转换 //String与int的转换 //String转int String s = \"123\"; int i = Integer.parseInt(s); //int转String int i = 123; String s = i+\"\"; 10进制转16进制 //10进制转16进制 int i = 324; String hex = Integer.toHexString(i); 大小写转换 String a = \"ABC\"; system.out.println(a.toLowerCase());//abc String b = \"abc\"; system.out.println(b.toUpperCase());//ABC 通过url获取json数据，在一般的Java类中运行正常，在安卓主界面却不行 通过url获取json代码 public static String loadJson (String urlStr) { //请求的url URL url = null; //建立的http链接 HttpURLConnection httpConn = null; //请求的输入流 BufferedReader in = null; //输入流的缓冲 StringBuilder sb = new StringBuilder(); try{ url = new URL(urlStr); in = new BufferedReader(new InputStreamReader(url.openStream(), \"UTF-8\") ); String str = null; //一行一行进行读入 while((str = in.readLine()) != null) { sb.append( str ); } } catch (Exception ignored) { } finally{ try{ if(in!=null) { in.close(); //关闭流 } }catch(IOException ignored) { } } return sb.toString(); } 调用 String url = getPropertiesUtil.getNetConfigProperties().getProperty(\"SERVER_URL\") + \"CheckCardIdentity?RFID=\" + RFID; String jsonString = GetData.loadJson(url);//调用上面的函数 System.out.println(\"请求的url:\" + url); System.out.println(\"user的json字符串\" + jsonString); JSONObject user = JSON.parseObject(jsonString); System.out.println(\"user的json格式\" + user); System.out.println(user.get(\"userName\")); //展示读卡的数据 System.out.println(\"data:\" + user.get(\"userName\")); 会访问不到json数据 解决方法：创建一个线程，让线程访问 final Thread getUserInfo = new Thread(new Runnable() @Override public void run() { try { //通过卡号查询用户信息的url String url = getPropertiesUtil.getNetConfigProperties().getProperty(\"SERVER_URL\") + \"CheckCardIdentity?RFID=\" + RFID; String jsonString = GetData.loadJson(url); JSONObject user = JSON.parseObject(jsonString); }catch (Exception e){ System.out.println(\"Have Exception:\"+e.getMessage()); } } }); //启动获取用户信息的线程 getUserInfo.start(); 还有一个问题 线程不能调用那个弹窗的方法 "},"工具/":{"url":"工具/","title":"工具","keywords":"","body":"Introduction "},"工具/IDEA.html":{"url":"工具/IDEA.html","title":"IDEA","keywords":"","body":"IDEA中配置MySQL出现Server returns invalid timezone问题解决方法 原因： 首先，出现该问题的原因是MySQL驱动jar中的默认时区是UTC。 UTC代表的是全球标准时间 ，但是我们使用的时间是北京时区也就是东八区，领先UTC八个小时。 因为时区不一致，所以提示Server returns invalid timezone. Go to 'Advanced' tab and set 'serverTimezone' property manually 服务器返回了无效的时区，去“高级”标签中手工设置“serverTimezon\"属性值。 解决方案： 去“高级”标签中手工设置“serverTimezon\"属性值为Asia/Shanghai 添加.gitignore并删除无用的配置文件后push到GitHub 创建.ignore type nul>.gitignore #windows下创建名为.gitignore的空文件 编辑.gitignore /target/ .idea *.iml 清理git缓存 git rm -r --cached .idea git rm -r --cached *.iml git commit -m \"删除无用配置文件\" VSC>Git>Push "},"工具/docker.html":{"url":"工具/docker.html","title":"Docker","keywords":"","body":"win10下安装docker 需要win10专业版，如果是家庭版可以通过更改产品密钥升级到专业版 看官方文档安装 git clone https://github.com/docker/doodle.git cd doodle\\cheers2019 docker build -t bluepyang/cheers2019 . docker run -it --rm bluepyang/cheers2019 docker login docker push bluepyang/cheers2019 一些命令 docker image ls # 列出本机的所有 image 文件 docker image rm [imageName] # 删除 image 文件 docker container ls # 列出本机正在运行的容器 docker container ls --all # 列出本机所有容器，包括终止运行的容器 docker image prune #清除none docker ps #查看正在运行的容器 docker run --name nginx-test -p 8080:80 -d nginx --name nginx-test：容器名称。 -p 8080:80： 端口进行映射，将本地 8080 端口映射到容器内部的 80 端口。 -d nginx： 设置容器在在后台一直运行。 "},"工具/github.html":{"url":"工具/github.html","title":"Github","keywords":"","body":"GitHub搜索技巧 in:name example 名字中有“example” in:readme example readme中有“example” in:description example 描述中有“example” stars:>1000 star>1000 forks:>1000 fork>1000 pushed:>2019-09-01 2019年9月1日后有更新的 language:java 用Java编写的项目 配置代理 git config --global http.proxy 'socks5://127.0.0.1:1080' git config --global https.proxy 'socks5://127.0.0.1:1080' 撤销代理： git config --global --unset http.proxy git config --global --unset https.proxy 查看代理： git config --global --get http.proxy git config --global --get https.proxy "},"数据库/":{"url":"数据库/","title":"数据库","keywords":"","body":"Introduction "},"数据库/MVCC.html":{"url":"数据库/MVCC.html","title":"MVCC","keywords":"","body":"MySQL-InnoDB-MVCC多版本并发控制 多版本并发控制: 指的是一种提高并发的技术。 最早的数据库系统，只有读读之间可以并发，读写，写读，写写都要阻塞。引入多版本之后，只有写写之间相互阻塞，其他三种操作都可以并行，这样大幅度提高了InnoDB的并发度。 MySQL官方文档描述 Internally, InnoDB adds three fields to each row stored in the database. A 6-byte DB_TRX_ID field indicates the transaction identifier for the last transaction that inserted or updated the row Each row also contains a 7-byte DB_ROLL_PTR field called the roll pointer A 6-byte DB_ROW_ID field contains a row ID that increases monotonically as new rows are inserted InnoDB向数据库中存储的每一行添加三个字段 6字节的DB_TRX_ID字段指示最后插入或更新该行的交易的交易标识符 每行还包含一个7字节的DB_ROLL_PTR字段，称为滚动指针 6字节的DB_ROW_ID字段包含一个行ID，该行ID随着插入新行而单调增加 undo log Undo log是InnoDB MVCC事务特性的重要组成部分 "},"数据库/MySQL.html":{"url":"数据库/MySQL.html","title":"MySQL","keywords":"","body":"MySQL 行：表中的一个记录 主键（primary key）：一列（或一组列），其值能唯一区分表中每个行 使用MySQL 展示所有数据库 show databases; 选择数据库 use crashcourse; 获取一个数据库内的表的列表 show tables; 显示表列，需要给出表名 show columns from customers; -- 下面语句等价 describe customers; 其他show语句 show status; -- 显示广泛的服务器状态信息 show create database; -- 显示创建特定数据库 show create table; -- 显示创建特定表 show grants; -- 显示授予用户的安全权限 show errors; -- 显示服务器错误 show warnings; --显示服务器警告 进一步了解show help show; 检索数据 select语句 检索单个列 select prod_name from products; 检索多个列 select prod_id, prod_name, prod_name from products; 检索所有列 select * from products; 检索不同的行（数据不重复） select distinct vend_id from products; -- distinct放在列名前面 限制结果 LIMIT子句 select prod_name from products limit 5; -- 只返回前5行数据，不够5行则返回所有数据 select prod_name from products limit 5,5; -- 返回从行5开始的5行，第一个数为开始位置，第二个数为行数 ==第一行为行0== 使用完全限定的表名 select products.prod_name from products; select products.prod_name from crashcourse.products; 检索排序数据 排序数据 ORDER BY子句 select prod_name from products order by prod_name; 按多个列排序 首先按prod_price排序，prod_price相同才按prod_name select prod_id, prod_price, prod_name from products order by prod_price, prod_name; 指定排序方向 默认升序(ASC)，使用DESC关键字降序 select prod_id, prod_price, prod_name from products order by prod_price DESC; 先按prod_price降序，再按prod_name升序 select prod_id, prod_price, prod_name from products order by prod_price DESC, prod_name; 过滤数据 使用WHERE子句 select prod_price, prod_name from products where prod_price = 2.50; where子句操作符 操作符 说明 = 等于 <> 不等于 != 不等于 小于 小于等于 > 大于 >= 大于等于 BETWEEN 在指定两个值之间 范围值检查 select prod_price, prod_name from products where prod_price between 5 and 10; 空值检查 select prod_name from products where prod_price is null; 数据过滤 组合where子句 允许给出多个where子句，子句之间用AND或OR联结 AND操作符 select prod_id, prod_price, prod_name from products where vend_id = 1003 AND prod_price OR操作符 select prod_price, prod_name from products where vend_id = 1002 OR vend_id = 1003; 计算次序 对于下面的语句，优先处理AND操作符（AND操作符在计算次序中优先级更高） select prod_price, prod_name from products where vend_id = 1002 OR vend_id = 1003 AND prod_price >= 10; 如果需要先计算OR联结的语句，需要加括号 select prod_price, prod_name from products where (vend_id = 1002 OR vend_id = 1003) AND prod_price >= 10; IN操作符 in用来指定条件范围 select prod_price, prod_name from products where vend_id in(1002,1003) order by prod_name; NOT操作符 否定后面的条件 select prod_price, prod_name from products where vend_id not in(1002,1003) order by prod_name; 用通配符过滤 LIKE操作符 %通配符 表示任何字符出现任何次数 select prod_id, prod_name from products where prod_name like 'jet%'; _通配符 匹配单个任意字符 select prod_id, prod_name from products where prod_name like '_ ton anvil'; 使用通配符技巧 不要过度使用通配符。优先使用其他能达到相同目的的操作符。 除非绝对有必要，否则不要把通配符放在搜索模式的开始处。这样搜索起来是最慢的 仔细注意通配符的位置 使用正则表达式进行搜索 基本字符匹配 检索文本包含1000的所有行 select prod_name from products where prod_name regexp '1000' order by prod_name; 与使用like关键词的语句非常像，只不过把like改为了regexp ==但是like匹配整个列值，一般需要搭配通配符使用== .000中 . 表示匹配任意一个字符 select prod_name from products where prod_name regexp '.000' order by prod_name; 正则表达式匹配不区分大小写，如果需要区分，则在regexp后面添加binary关键字 进行OR匹配 搜索两个串之一，使用|，可以给出两个以上的OR条件 select prod_name from products where prod_name regexp '1000|2000' order by prod_name; 匹配几个字符之一 使用一组用[和]括起来的字符 select prod_name from products where prod_name regexp '[123] Ton' order by prod_name; 123则匹配除这些字符以外的任意字符 匹配范围 [0123456789]可简写为[0-9] 匹配特殊字符 -- 加\\\\为前导 \\\\-表示查找- ， \\\\.表示查找. 元字符 说明 \\\\f 换页 \\\\n 换行 \\\\r 回车 \\\\t 制表 \\\\v 纵向制表 ==为了匹配\\本身，需要使用\\\\\\== 匹配字符类 类 说明 [:alnum:] 任意字母和数字（同[a-zA-Z0-9]） [:alpha:] 任意字符（同[a-zA-Z]） [:blank:] 空格和制表（同[\\\\t]） [:cntrl:] ASCII控制字符（ASCII0到31和127） [:digit:] 任意数字（同[0-9]） [:graph:] 与[:print:]相同，但不包含空格 [:lower:] 任意小写字母（同[a-z]） [:print:] 任意可打印字符 [:punct:] 既不在[:alnum:]又不在[:cntrl:]中的任意字符 [:space:] 包括空格在内的任意空白字符（同[\\\\\\f\\\\n\\\\r\\\\t\\\\v]） [:upper:] 任意大写字母（同[A-Z]） [:xdigit:] 任意十六进制数字（同[a-fA-F0-9]） 匹配多个实例 元字符 说明 * 0个或多个匹配 + 1个或多个匹配（等于{1,}） ? 0个或1个匹配（等于{0,1}） {n} 指定数目的匹配 {n,} 不少于指定数目的匹配 {n,m} 匹配数目的范围（m不超过255） select prod_name from products where prod_name regexp '\\\\([0-9] sticks?\\\\)' order by prod_name; 输出示例 TNT (1 stick) TNT (5 sticks) 分析：\\\\( 匹配 ( ,[0-9]匹配任意数字，sticks?匹配stick和sticks，\\\\)匹配) 定位符 元字符 说明 ^ 文本的开始 $ 文本的结尾 [[: 词的开始 [[:>:]] 词的结尾 如果想要找出以一个数（包括以小数点开始的数）开始的所有产品，使用[0-9\\\\.]不行，因为它在文本内任意位置查找匹配。解决方法是使用定位符^ select prod_name from products where prod_name regexp '^[0-9\\\\.]' order by prod_name; ^的双重用途：在集合中，用它来否定该集合，否则用来指串的开始处 创建计算字段 计算字段并不实际存在于数据库表中。计算字段是运行时在SELECT语句内创建的。 字段：基本上与列的意思相同 拼接字段 拼接：将值联结到一起构成单个值 在MySQL的SELECT语句中，可使用==Concat()函数==来拼接两个列 select Concat(vend_name,'(',vend_country,')') from vendors order by vend_name; Trim()函数：去除串左右两边的空格 LTrim()：去除左边的空格 RTrim()：去除右边的空格 使用别名 select Concat(vend_name,'(',vend_country,')') as vend_title from vendors order by vend_name; 执行算术计算 select prod_id, quantity, item_price, quantity*item_price AS expanded_price from orderitems where order_num = 20005; 使用数据处理函数 文本处理函数 Trim() Upper() Lower() Soundex()：返回串的soundex值，能对串进行发音比较 …… 日期和时间处理函数 日期格式必须为yyyy-mm-dd MySQL中存在类型datetime，格式为：yyyy-MM-dd HH:mm:ss 如果要的只是日期，需要使用Date()函数，也存在一个Time()函数 数值处理函数 Abs() Cos() Exp() Mod() …… 汇总数据 聚集函数 运行在行组上，计算和返回单个值的函数 AVG() 返回某列的平均值 忽略列值为null的行 select AVG(prod_price) AS avg_price FROM products; COUNT() 返回某列的行数 如果指定列名，值为null的行将被忽略。如果使用COUNT(*)，则不忽略 select COUNT(*) AS num_cust FROM customers; MAX() 返回某列的最大值，忽略值为null的行 一般用于数值或日期值。在用于文本数据时，如果数据按相应列排序，则MAX()返回最后一行 MIX() 返回某列的最小值,与MAX相反 SUN() 返回某列值值和 聚集不同值 ALL为默认，对所有的行执行操作 DISTINCT，只包含不同的值 组合聚集函数 可以同时使用多个聚集函数 select COUNT(*) AS num_item, MIN(prod_price) AS price_min, MAX(prod_price) AS price_max, AVG(prod_price) AS price_avg from products; 取别名 不应该使用表中实际的列名。并非不合法，但是使用唯一的名字会使SQL更易于理解 分组数据 GROUP BY子句 group by子句指示MySQL分组数据，然后对每个组而不是整个结果集进行聚集 select vend_id, COUNT(*) AS num_prods FROM products group by vend_id; 重要规定 group by子句可以包含任意数目的列 如果在group by子句中嵌套了分组，数据将在最后规定的分组上进行汇总 group by子句中列出的每个列都必须是检索列或有效的表达式（但是不能是聚集函数） 除聚集计算语句外，select语句中的每个列都必须在group by子句中给出 如果分组列中具有null值，则null将作为一个分组返回 group by子句必须出现在where子句之后，order by子句之前 使用ROLLUP：使用关键字with rollup可以得到每个分组以及每个分组汇总级别的值 过滤分组 where过滤指定的是行而不是分组 可以使用having子句过滤分组，having支持所有where操作符 select cust_id, COUNT(*) AS orders FROM orders group by cust_id HAVING COUNT(*)>=2; 分组和排序 一般在使用group by子句时，应该也给出order by子句 select子句顺序 select→from→where→group by→having→order by→limit 使用子查询 子查询：嵌套在其他查询里的查询 子查询总是从内向外处理 一般与IN操作符结合使用 以下两条语句可合并为一条 SELECT order_num from orderitems where prod_id = 'TNT2'; -- 查询结果为 20005 20007 SELECT cust_id from orders where order_num IN(20005,20007); -- 查询结果为10001 10004 使用子查询 SELECT cust_id from orders where order_num IN(SELECT order_num from orderitems where prod_id = 'TNT2'); 连结表 联结是利用SQL的select能执行的最重要的操作 主键 外键 涉及两个表的查询，在引用的列可能出现二义性时，必须使用完全限定列名。 select vend_name, prod_name, prod_price from vendors, products where venders.vend_id = products.vend_id order by vend_name, prod_name; 如果不使用where子句建立联结条件，那么返回的结果为笛卡尔积。 select vend_name, prod_name, prod_price from vendors, products order by vend_name, prod_name; ==应该保证所有的联结都有where子句== 内部联结 内部联结，也称为等值联结，基于两表之间的相等测试 select vend_name, prod_name, prod_price from vendors INNER JOIN products ON venders.vend_id = products.vend_id; 使用INNER JOIN之后，用ON子句指定联结条件 联结多个表 联结的表越多，性能下降的越厉害 select vend_name, prod_name, prod_price, quantity from vendors, products,orderitems where venders.vend_id = products.vend_id AND orderitems.prod_id = products.prod_id AND order_num = 20005; 创建高级联结 使用表别名 缩短SQL语句 允许单条SELECT语句中多次使用相同表 SELECT cust_name, cust_contact FROM customers AS c, orders AS o, orderitems AS oi WHERE c.cust_id = o.cust_id AND oi.order_num = o.order_num AND prod_id = 'TNT2'; 使用不同类型的联结 自联结 假如发现某物品（其ID为DTNTR）存在问题，因此想知道生产该物品的供应商生产的其他物品是否存在问题。 使用子查询 SELECT prod_id, prod_name FROM products WHERE vend_id = (SELECT vend_id FROM products WHERE prod_id = 'DTNTR'); 使用联结的相同查询 SELECT prod_id, prod_name FROM products AS p1, products AS p2 WHERE p1.vend_id = p2.vend_id AND p2.prod_id = 'DTNTR'; 此查询中需要的两个表实际上是相同的表，通过使用别名避免二义性。 使用自联结比子查询效率更高。 自然联结 对表进行联结，应该至少有一个列出现在不止一个表中，标准的联结返回所有数据，甚至相同的列多次出现。自然联结排除多次出现，使每个列只返回一次 一般通过对表使用通配符(SELECT *)，对其他表的列使用明确的子集来完成。 SELECT c.*, o.order_num, o.order_date, oi.prod_id, oi.quantity, oi.item_price FROM customers AS c, orders AS o, orderitem AS oi WHERE c.cust_id = o.cust_id AND oi.order_num = o.order_num AND prod_id = 'FB'; 通配符只对第一个表使用。所有其他列明确列出，所以没有重复的列被检索出来。 外部联结 SELECT customers.cust_id, order.order_num FROM customers LEFT OUTER JOIN orders ON customers.cust_id = orders.cust_id; 使用了OUTER JOIN来指定联结的类型。与内部联结不同的是外部联结还包括没有关联的行。 使用LEFT或RIGHT关键词指定包括其所有行的表 上面例子中使用LEFT OUTER JOIN 从customers表中选择所有行，即左（外）连接 下面展示右（外）连接 SELECT customers.cust_id, order.order_num FROM customers RIGHT OUTER JOIN orders ON customers.cust_id = orders.cust_id; 使用带聚集函数的联结 SELECT customers.cust_name, customers.cust_id, COUNT(orders.order_num) AS num_ord FROM customers INNER JOIN orders ON customers.cust_id = orders.cust_id GROUP BY customers.cust_id; 使用联结和联结条件 注意使用的联结类型 保证使用正确的联结条件 应该总是提供联结条件，否则会得出笛卡尔积 在一个联结中可以包含多个表，甚至对于每个联结可以采用不同的联结类型 组合查询 有两种基本情况，其中需要使用组合查询： 在单个查询中从不同的表返回类似结构的数据 对单个表执行多个查询，按单个查询返回数据 创建组合查询 UNION操作符 以下两条SELECT语句可使用UNION组合 SELECT vend_id, prod_id, prod_price FROM products WHERE prod_price 组合 SELECT vend_id, prod_id, prod_price FROM products WHERE prod_price 给出使用多条WHERE子句而不是使用UNION的相同查询 SELECT vend_id, prod_id, prod_price FROM products WHERE prod_price 这里使用UNION可能比使用WHERE子句更复杂，但是对于更复杂的过滤条件，或者从多个表中检索数据的情形，使用UNION可能会使处理更简单 UNION规则 必须由两条或以上SELECT语句组成 每个查询必须包含相同的列，表达式或聚集函数（次序可不同） 列数据类型必须兼容：类型不必完全相同，但必须是DBMS可以隐含地转换的类型 包含或取消重复的行 UNION从查询结果集中自动去除了重复的行 如果想匹配所有行，可使用UNION ALL而不是UNION 对组合查询结果排序 SELECT语句的输出用ORDER BY子句排序。 在用UNION组合查询时，只能用一条ORDER BY子句，它必须出现在最后一条SELECT语句之后 全文本搜索 并非所有引擎都支持全文本搜索 MyISAM支持，InnoDB不支持 使用全文本搜索 为了进行全文本搜索，必须索引被搜索的列，而且要随着数据的改变不断地重新索引 在对表列进行适当设计后，MySQL会自动进行所有的索引和重新索引 启用全文本搜索支持 一般在创建表时启用全文本搜索。CREATE TABLE语句接收FULLTEXT子句，它给出被索引列的一个逗号分隔的列表。 CREATE TABLE productnotes ( note_id int NOT NULL AUTO_INCREMENT, prod_id char(10) NOT NULL, note_date datetime NOT NULL, note_text text NULL , PRIMARY KEY(note_id), FULLTEXT(note_text) ) ENGINE=MyISAM; 有一个名为note_text的列，为了进行全文本搜索，MySQL根据子句FULLTEXT(note_text)的指示对它进行索引。 进行全文本搜索 使用两个函数Match()和Against()执行全文本搜索，其中Match()指定被搜索的列，Against()指定要使用的搜索表达式。 SELECT note_text FROM productnotes WHERE Match(note_text) Against('rabbit'); 此select语句检索单个列note_text，由于WHERE子句，一个全文本搜索被执行。Match(note_text)指示MySQL针对的列进行搜索，Against('rabbit')指定词rabbit作为搜索文本。 Match()说明：传递给Match()的值必须与FULLTEXT()定义中的相同。如果指定多个列，则必须列出它们（而且次序正确）。 搜索不区分大小写：除非使用BINARY方式。 事实上，刚才的搜索可以简单的用like子句替换 SELECT note_text FROM productnotes WHERE note_text LIKE '%rabbit%'; LIKE以不特别有用的顺序返回数据。 全文本搜索返回以文本匹配的良好程度排序的数据。 使用查询扩展 SELECT note_text FROM productnotes WHERE Match(note_text) Against('anvils' WITH EXPANSION); 行越多使用扩展查询返回的结果越好 布尔文本搜索 SELECT note_text FROM productnotes WHERE Match(note_text) Against('heavy' IN BOOLEAN MODE); 全文本搜索的使用说明 在索引全文本数据时，短词被忽略且从索引中排除 MySQL带有一个内建的非用词（stopword）列表，这些词在索引全文本数据时总是被忽略 许多次出现的频率很高，搜索它们没有用处。MySQL制定了一条50%规则 如果表中的行数少于3行，则全文本搜索不返回结果 忽略词中的单引号 不具有词分隔符的语言不能恰当地返回全文本搜索结果 仅在MyISAM数据库索引中支持全文本搜索 插入数据 插入完整的行 INSERT INTO Customers VALUES(NULL, 'Pep E. LaPew', '100 Main Street', 'Los Angeles', 'CA', '90046', 'USA', NULL, NULL); 更安全的方式 INSERT INTO Customers(cust_name, cust_contact, cust_email, cust_address, cust_city, cust_state, cust_zip, cust_conutry) VALUES('Pep E. LaPew', NULL, NULL, '100 Main Street', 'Los Angeles', 'CA', '90046', 'USA'); 必须给出VALUES的正确数目。如果不提供列名，则必须给每个列提供一个值。如果提供列名，则必须对每个列出的列给出一个值。 省略列 该列定义为允许NULL值 在表定义中给出默认值 插入多行 多条INSERT语句 或者 INSERT INTO customers(……) VALUES(……),(……); 插入某些查询的结果 INSERT SELECT 更新和删除数据 更新数据 更新特定行 更新所有行 不要省略WHERE子句 UPDATE语句三部分 要更新的表 列名和它们的新值 确定要更新行的过滤条件 UPDATE customers SET cust_email = 'elmer@fudd.com' WHERE cust_id = 10005; 如果用UPDATE更新多行，更新时可能会出现错误，那么则整个更新操作都会被取消。 如果想即使发生错误也要继续更新，可以使用IGNORE关键字，示例UPDATE IGNORE customers... 删除数据 删除特定行 删除所有行 不要省略WHERE子句 DELETE FROM customers WHERE cust_id = 10006; 删除所有行：使用TRUNCATE TABLE truncate实际是删除原来的表并重新创建一个表，而不是逐行删除数据 创建和操纵表 创建表 create table customers( cust_id int NOT NULL AUTO_INCREMENT, cust_name char(50) NOT NULL, cust_address char(50) NULL, cust_city char(50) NULL, cust_state char(5) NULL, cust_zip char(10) NULL, cust_country char(50) NULL, cust_contact char(50) NULL, cust_email char(255) NULL, PRIMARY KEY (cust_id) )ENGINE=InnoDB; 确定AUTO_INCREMENT的值 使用 SELECT last_insert_id()函数，返回最后一个AUTO_INCREMENT值 引擎类型 InnoDB：可靠的事务处理引擎，不支持全文本搜索 MEMORY：功能等同于MyISAM，但用于数据存储在内存（不是磁盘）中，速度很快（特别适合于临时表） MyISAM：性能极高的引擎，支持全文本搜索，但不支持事务处理 外键不能跨引擎 更新表 ALTER TABLE ALTER TABLE venders ADD vend_phone CHAR(20); -- 添加列 ALTER TABLE venders DROP COLUMN vend_phone; -- 删除列 常见用途：定义外键 ALTER TABLE orderitems ADD CONSTRAINT fk_orderitems_orders FOREIGN KEY (order_num) REFERENCES orders (order_num); 删除表 DROP TABLE customers2; 重命名表 RENAME TABLE customers2 TO customers; 使用视图 使用存储过程 使用游标 使用触发器 :star:管理事务处理 事务处理 并非所有引擎都支持事务处理：InnoDB支持，MyISAM不支持 维护数据库的完整性，保证成批的MySQL操作要么完全执行，要么完全不执行 几个术语： 事务（transaction）：指一组SQL语句 回退（rollback）：指撤销指定SQL语句的过程 提交（commit）：指将未存储的SQL语句写入数据库表 保留点（savepoint）：指事务发布中设置的临时占位符（placeholder），可以对它发布回退（与回退整个事务不同） 控制事务处理 使用ROLLBACK SELECT * FROM ordertotals; START TRANSACTION -- 标识事务开始 DELETE FROM ordertotals; SELECT * FROM ordertotals; ROLLBACK; -- 回滚 SELECT * FROM ordertotals; 事务处理用来管理INSERT、UPDATE、DELETE语句。不能回退SELECT语句（没意义），不能回退CREATE、DROP操作，事务管理中可以使用这两条语句，但是执行回退并不会被撤销。 使用COMMIT START TRANSACTION -- 标识事务开始 DELETE FROM ordertotals WHERE order_num = 20010; DELETE FROM orders WHERE order_num = 20010; COMMIT; -- 提交 当COMMIT或ROLLBACK语句执行后，事务会自动关闭（将来的更改会隐含提交） 使用保留点 SAVEPOINT delete1; ROLLBACK TO delete1; 保留点越多越好 保留点在事务处理完成后（执行一条）自动释放，MySQL 5以来，也可以使用RELEASE SAVEPOINT明确地释放保留点。 更改默认的提交行为 默认MySQL行为是自动提交所有更改。为指示MySQL不自动提交更改，需要使用以下语句 SET autocommit=0; autocommit标志决定是否自动提交更改，不管有没有commit语句。设置autocommit为0（假）指示MySQL不自动提交更改（直到autocommit被设置为真为止） autocommit标志是针对每个连接而不是服务器的 全球化和本地化 使用字符集和校对顺序 show character set; -- 显示所有可用的字符集以及每个字符集的描述和默认校对 show collation; -- 显示所有可用的校对，以及它们适用的字符集 安全控制 管理用户 use mysql; SELECT user FROM user; 创建用户账号 create USER ben IDENTIFIED by 'p@$$w0rd'; 重命名用户账号 RENAME USER ben TO bforta; 删除用户账户 DROP USER bforta; 设置访问权限 show grants for bforta; -- 查看赋予用户的权限 -- 显示有一个权限USAGE ON *.* USAGE表示根本没有权限 设置权限，使用GRANT语句。至少要使用以下信息： 要授予的权限 被授予访问权限的数据库或表 用户名 GRANT SELECT ON crashcourse.* TO bforta; -- 允许bforta用户在crashcourse.*上使用select 反操作REVOKE撤销权限 REVOKE SELECT ON crashcourse.* TO bforta; -- 撤销bforta用户在crashcourse.*上使用select权限 几个层次上的控制访问权限 整个服务器：GRANT ALL和REVOKE ALL 整个数据库：使用ON database.* 特定的表：使用ON database.table 特定的列 特定的存储过程 更改口令 set password for bforta = Password('n3w p@$$w0rd'); 不指定用户名则更新当前登录用户的口令 数据库维护 备份数据 进行数据库维护 诊断启动问题 查看日志文件 改善性能 "},"数据库/Redis.html":{"url":"数据库/Redis.html","title":"Redis","keywords":"","body":"NoSQL概述 大数据时代 单机时代 存在的问题 数据量太大，一个机器放不下 数据的索引（B+ Tree），一个机器内存放不下 访问量（读写混合），一个服务器承受不了 Memcached（缓存）+ MySQL+垂直拆分 网站80%情况都是在读，每次去查询十分麻烦！减轻压力，使用缓存。 分库分表 + 水平拆分 + MySQL集群 早些年MyISAM：表锁 InnoDB：行锁 如今最近的年代 热榜实时更新，数据量大，变化快 MySQL关系型数据库不够用 什么是NoSQL Not Only SQL 泛指非关系型数据库 使用键值对来控制 NoSQL特点 方便扩展（数据之间没有关系，很好扩展） 大数据量高性能（Redis 1秒写8万次，读11万，缓存记录性能高） 数据类型多样（不需要设计数据库，随取随用） 传统RDBMS和NoSQL 传统的 RDBMS - 结构化组织 - SQL - 数据和关系都存在单独的表中 - 操作操作，数据定义语言 - 严格的一致性 - 基础的事务 …… NoSQL - 不仅仅是数据 - 没有固定的查询语言 - 键值对存储，列存储，文档存储，图形数据库 - 最终一致性 - CAP定理和BASE - 高性能，高可用，高可扩 … 大数据的3V和3高 NoSQL的四大分类 KV键值对： Redis 文档型数据库（bson格式和json）： MongoDB 分布式文件存储的数据库，c++编写，处理大量文档 介于关系型与非关系型数据库之间 列存储数据库： 图关系数据库：存关系 Redis入门 Remote Dictionary Server 能干啥？ 内存存储，持久化（rdb、aof） 效率高，可以用于高速缓存 发布订阅系统 地图信息分析 计时器、计数器（浏览量） …… 特性： 多样数据类型 持久化 集群 事务 Windows安装 https://github.com/rgl/redis/downloads Linux安装 6.x以上版本需要更新gcc tar -xzvf make make install 修改配置文件后台启动 daemonize yes 测试性能 redis-benchmark -h localhost -p 6379 -c 100 -n 100000 基本命令 清空当前数据库flushdb 清空全部数据库flushall 基础知识 Redis是单线程的 6.0.0以后是多线程 16个数据库，默认使用第0个 命令 set #set key get #get key keys * #查看所有key exists #判断当前key是否存在 move #移除当前key expire #设置key时间过期 ttl #查看当前key的剩余时间 type #查看key类型 五大数据类型 Redis-Key String append [key] [string] #追加字符串 strlen [key] #获取字符串长度 incr #加一 decr #减一 incrby [key] 10 #一次加10（步长） decrby getrange [key] 0 3 #截取字符串[0,3]（0 -1所有同get key） setrange [key] setex #set with expire setnx #set if not exist mset mget 127.0.0.1:6379> mset k1 v1 k2 v2 k3 v3 OK 127.0.0.1:6379> mget k1 k2 k3 1) \"v1\" 2) \"v2\" 3) \"v3\" 127.0.0.1:6379> msetnx k1 v1 k4 v4 #原子性操作 (integer) 0 127.0.0.1:6379> get k4 (nil) #对象 set user:{id}:{filed} 127.0.0.1:6379> getset db redis #如果不存在，相当于set (nil) 127.0.0.1:6379> get db \"redis\" 127.0.0.1:6379> getset db mongodb #如果存在，先get再set \"redis\" 127.0.0.1:6379> get db \"mongodb\" List 127.0.0.1:6379> LPUSH list one (integer) 1 127.0.0.1:6379> LPUSH list two (integer) 2 127.0.0.1:6379> LPUSH list three (integer) 3 127.0.0.1:6379> LRANGE list 0 -1 1) \"three\" 2) \"two\" 3) \"one\" 127.0.0.1:6379> LRANGE list 0 1 1) \"three\" 2) \"two\" 127.0.0.1:6379> rpush list right (integer) 4 127.0.0.1:6379> LRANGE list 0 -1 1) \"three\" 2) \"two\" 3) \"one\" 4) \"right\" 127.0.0.1:6379> LPOP list #移除list第一个 \"three\" 127.0.0.1:6379> RPOP list #移除list最后一个 \"right\" 127.0.0.1:6379> LRANGE list 0 -1 1) \"two\" 2) \"one\" 127.0.0.1:6379> lindex list 0 #通过下标获取值 \"two\" 127.0.0.1:6379> lindex list 1 \"one\" 127.0.0.1:6379> LLEN list #获取长度 (integer) 2 lrem #移除list中指定个数的值 ltrim #通过下标截取指定长度，list只剩下截取的元素 rpoplpush #移除列表的最后一个元素到新列表 lset #将列表指定下标的值替换为另一个值，即更新操作 linsert #可指定前面后面位置插入 Set 不重复 sadd myset smembers myset sismember srem #移除指定元素 scard #set中元素个数 srandmember myset #随机抽出指定元素 spop #随机删除 sdiff #差集 sinter #交集 sunion #并集 Hash Map集合，key-map 本质和String没有什么区别，还是一个简单的key-value hset myhash field value hget hmset hmget hgetall hdel hlen hexists myhash field hincrby hsetnx 对象用hash存储方便 Zset（有序集合） zadd zrange zrangebyscore key min max zcard #获取有序集合中的个数 zcount #获取指定区间的成员数量 三种特殊类型 geospatial地理位置 Redis的Geo GEOADD GEODIST GEOHASH GEOPOSH GEOADIUS Hyperloglog 什么是基数？（不重复的元素） 用来做基数统计的算法 PFADD mykey a b c d e f g h i j PFCOUNT mykey PFADD mykey2 i j k l m n o PFMERGE mykey3 mykey2 mykey Bitmaps 位存储 两个状态0 1 setbit getbit bitcount 事务 Redis事务本质：一组命令的集合！一个事物中所有命令都会序列化，在事务执行过程中，会按照顺序执行！ 一次性、顺序性、排他性！执行一些列的命令 ==Redis单条命令保证原子性，但是事务不保证原子性== Redis事务没有隔离级别的概念 Redis的事务： 开启事务（multi） 命令入队（……） 执行事务（exec） 正常执行事务 放弃事务 discard 编译异常 全部命令不执行 运行异常 其他命令正常执行 监控 悲观锁： 认为什么时候都会出问题，无论做什么都加锁 乐观锁： 认为什么时候都不会出现问题，所有不会上锁！更新数据的时候去判断一下，在此期间是否有人修改过这个数据 获取version 更新的时候比较version Redis测监视测试 Jedis Redis配置文件 配置文件 unit单位 对大小写不敏感 Redis持久化 RDB（snapshotting）（Redis默认持久化） ==保存的文件是dump.rdb== 都是在配置文件快照中进行配置 触发机制 save的规则满足的情况下，会自动触发rdb规则 执行flushall命令，也会触发rdb规则 退出redis，也会产生rdb文件 备份就自动生成一个dump.rdb 恢复rdb文件 在redis启动目录中放rdb文件 save 900 1 #在900秒（15分钟）之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照 save 300 10 #在300秒（5分钟）之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照 save 60 10000#在60秒（1分钟）之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照 AOF（Append Only File） ==保存的文件是appendonly.aof== 将我们所有命令记录下来，恢复的时候重新执行 默认不开启，将appendonly no改为yes即可生效 appendfsync always #每次有数据修改发生时都会写入AOF文件，这样会严重降低Redis的速度 appendfsync everysec #每秒钟同步一次，显示地将多个命令同步到硬盘 appendfsync no #让操作系统决定何时进行同步 重启，redis就可以生效了 aof文件有问题，无法启动redis redis提供了一个工具redis-check-aof Redis发布订阅 redis 127.0.0.1:6379> SUBSCRIBE ylldgzh Reading messages... (press Ctrl-C to quit) 1) \"subscribe\" 2) \"ylldgzh\" 3) (integer) 1 1) \"message\" 2) \"ylldgzh\" 3) \"hello,yll\" 1) \"message\" 2) \"ylldgzh\" 3) \"hello,redis\" #等待读取信息 #发送端 redis 127.0.0.1:6379> PUBLISH ylldgzh \"hello,yll\" (integer) 1 redis 127.0.0.1:6379> PUBLISH ylldgzh \"hello,redis\" (integer) 1 redis 127.0.0.1:6379> Redis主从复制 是指将一台Redis服务器的内容，复制到其他Redis服务器，前者称为主节点，后者称为从节点 数据的复制是单向的。 主从复制，读写分离！ info replication 配置三台Redis服务器 一主二从 默认都是主节点，一般只需要配置从机 127.0.0.1:6380> SLAVEOF 127.0.0.1 6379 #认主机 OK 127.0.0.1:6380> info replication # Replication role:slave master_host:127.0.0.1 master_port:6379 master_link_status:down master_last_io_seconds_ago:-1 master_sync_in_progress:0 slave_repl_offset:1 master_link_down_since_seconds:1592916819 slave_priority:100 slave_read_only:1 connected_slaves:0 master_replid:94c953e3da093a084e25e06eb232fb7eb12e5d14 master_replid2:0000000000000000000000000000000000000000 master_repl_offset:0 second_repl_offset:-1 repl_backlog_active:0 repl_backlog_size:1048576 repl_backlog_first_byte_offset:0 repl_backlog_histlen:0 127.0.0.1:6380> 真实的配置是 在配置文件中配置，这样是永久的 用命令，是暂时的 主机可以写，从机不能写只能读！主机中所有信息和数据，都会复制到从机 测试:主机断开连接，从机依旧连接到主机，但是没有写操作，这个时候，主机如果回来了，从机依旧可以直接获取到主机写的信息！ 主机断开，从机可使用命令 slaveof no one让自己变成主机下 哨兵模式 （自动选老大） 测试 配置哨兵配置文件sentinel.conf sentinel monitor myredis 127.0.0.1 6379 1 后面的数字1，代表主机挂了，slave投票看让谁接替成为主机，票数最多的成为主机 redis-sentinel sentinel.conf #开启哨兵 主机宕掉后再回来只会成为新主机的从机 Redis缓存穿透和雪崩 服务的高可用问题 缓存穿透 差不多 用户想要查询数据，发现redis内存数据库没有，也就是缓存没有命中，于是向持久层数据库查询。发现也没有，于是本次查询失败。当用户很多时。缓存都没有命中，于是都去请求持久层数据库。这给持久层数据库造成很大的压力，这时候相当于出现了缓存穿透 解决方案 布隆过滤器 是一种数据结构 缓存空对象 缓存击穿 查询量太大，缓存过期 缓存雪崩 缓存集中过期失效，Redis宕机 "},"数据结构知识/":{"url":"数据结构知识/","title":"数据结构知识","keywords":"","body":"Introduction "},"数据结构知识/大话数据结构笔记1.html":{"url":"数据结构知识/大话数据结构笔记1.html","title":"大话数据结构笔记1","keywords":"","body":"大话数据结构笔记（一） 数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及他们之间的关系和操作等相关问题的学科。 CHAP 1数据结构绪论 基本概念和术语 数据：描述客观事物的符号。是计算机可以操作的对象 不仅包括整型，实型等数值类型，还包括字符，声音、图像、视频等非数值（通过编码手段转换为字符数据来处理）类型 数据元素：组成数据的有一定意义的基本单位 例如，人类中，数据元素就是人 数据项：若干数据项组成一个数据元素 数据项是数据不可分割的最小单位 数据对象：是性质相同的数据元素的集合，是数据的子集 数据结构：是相互之间存在一种或多种特定关系的数据元素的集合 有什么具体关系呢？ 逻辑结构和物理结构 逻辑结构：数据对象中数据元素之间的相互关系 集合结构：平等，只是同属于一个集合，相互之间并无关系 线性结构：一对一关系 树形结构：一对多关系 图形结构：多对多关系 物理结构：数据的逻辑结构在计算机中的存储形式 顺序存储结构：数据元素存放在连续的存储单元里 链式存储结构：数据元素存放在任意的存储单元，需要用一个指针存放数据元素地址 逻辑结构是面向问题的 物理结构是面向计算机的 抽象数据类型 数据类型:一组性质相同的值的集合及定义在次集合上的一些操作的总称 抽象数据类型:一个数学模型及定义在此模型上的一组操作 抽象数据类型体现了程序设计中问题的分解、抽象和信息隐藏的特性 小结 数据结构相关概念 数据 数据对象 数据元素 数据元素 数据元素 数据元素 数据项1 数据项2 数据项3 数据项4 数据项5 数据项6 数据项7 数据项8 结构分类 逻辑结构 集合结构 线性结构 树形结构 图形结构 物理结构 顺序存储结构 链式存储结构 抽象数据类型 "},"数据结构知识/大话数据结构笔记2.html":{"url":"数据结构知识/大话数据结构笔记2.html","title":"大话数据结构笔记2","keywords":"","body":"大话数据结构笔记（二） 数据结构与算法的关系 就像梁山伯与祝英台，罗密欧与朱丽叶。不可只谈数据结构不谈算法。 两种算法的比较 求1+2+3+ ... +100 int i, sum = 0, n = 100; for( i = 1; i 需要循环100次:sweat: //高斯的方法 int i, sum = 0, n = 100; sum = (1 + n)*n/2; printf(\"%d\",sum); 求等差数列的算法，不需要循环:+1: 算法定义 算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作 算法特性 输入：有零个或多个输入 输出：至少一个输出 有穷性：总能在有限步后终止，且每步在可接受时间内完成 确定性：每一步有确定的含义，无二义性 可行性：每一步都可行 算法设计的要求 正确性：没有语法错误，反映问题需求，能得到正确答案，非法输入也有说明 可读性：便于阅读、理解和交流 健壮性：输入数据不合法时也也能做出相关处理，而不是产生异常或莫名其妙的结果 算法效率的度量方法 事后统计方法：通过设计好的测试程序和数据，比较运行时间 缺陷 需要编写测试程序，费时费力 受环境因素影响，机器运行时环境难以保存相同 算法测试数据设计困难 事前分析估算方法：程序编制前，依据统计方法对算法进行估算 算法运行时间取决于 算法采用的策略，方法 :arrow_right: 算法好坏的根本 编译产生的代码质量​ ​ :arrow_right: 需要软件来支持 问题的输入规模 机器执行指令的速度​ ​ :arrow_right: 看硬件性能 一个程序的运行时间，依赖于算法的好坏和问题的输入规模。 问题的输入规模即输入量的多少 函数的渐进增长 给定两个函数f(n)和g(n)，如果存在一个整数N，使得对于所有的n > N，f(n)总是比g(n)大，那么f(n)的渐进增长快于g(n) 假设算法A和B的输入规模相同，A要做2n+3次操作，B要进行3n+1次操作 次数 算法A(2n+3) 算法A'(2n) 算法B(3n+1) 算法B'(3n) n=1 5 2 4 3 n=2 7 4 7 6 n=3 9 6 10 9 n=10 23 20 31 30 n=100 203 200 301 300 n=1时，算法A不如算法B，n>2时，算法A就开始优于算法B了 我们可以忽略加法常数 同理 最高次项相乘的常数并不重要 最高次项的指数大的，函数随着n的增长，结果也会变得增长特别快 判断算法的效率时，更应该关注最高阶项的阶数 算法的时间复杂度 时间复杂度定义 语句执行次数T(n)是关于问题规模n的函数。算法的时间复杂度记作：T(n)=O(f(n)) 它表示随问题规模的增大，算法执行时间的增长率和f(n)的增长率相同 推导大O阶方法 用常数1取代运行时间中的所有加法常数 在修改后的运行次数函数中，只保留最高阶项 如果最高阶项存在且不是1，去除与这个项相乘的常数 得到的结果就是大O阶 常见的时间复杂度 $$ O(1) $$ 最坏情况和评价情况 平均运行时间是所有情况中最有意义的 一般没有特殊说明，都指最坏复杂度 算法空间复杂度 "},"面试笔试/":{"url":"面试笔试/","title":"面试笔试","keywords":"","body":"Introduction "},"面试笔试/字节跳动5月11日笔试.html":{"url":"面试笔试/字节跳动5月11日笔试.html","title":"字节跳动5月11日笔试","keywords":"","body":"简易文本编辑器 题目描述 输入： 第一行 正整数N表示N个命令 接下来每一行表示一个命令 1 xx 追加xx到内容后面 2 k 删除最后k个字符 3 k 输出S的第k个字符 4 回滚上一步对S的操作，只有1和2 示例输入 8 1 abc 3 3 2 3 1 xy 3 2 4 4 3 1 实例输出 c y a 笔试时写出的代码，ac public class Main { private static Stack stack;//保存操作，方便回滚（只保存1，2） private static int[] command;//命令数组 private static String[] val;//命令对应的值的数组 private static StringBuilder str;//文本框中的内容 private static Stack del;//删除操作删除的字符串 public static void main(String[] args) { Scanner s = new Scanner(System.in); str = new StringBuilder(); int N = s.nextInt(); command = new int[N]; val = new String[N]; for (int i = 0; i (); del = new Stack<>(); //遍历命令字符串数组，依次执行命令 for (int i = 0; i = str.length()) del.push(String.valueOf(str)); else del.push(str.substring(str.length() - Integer.parseInt(val[i]), str.length())); //删除字符串 if (Integer.parseInt(val[i]) >= str.length()) str.delete(0, str.length()); else str.delete(str.length() - Integer.parseInt(val[i]), str.length()); } //命令3，输出字符 if (command[i] == 3) { int index = Integer.parseInt(String.valueOf(val[i])) - 1; System.out.println(str.charAt(index)); } //命令4，回滚 if (command[i] == 4) rollback(); //命令1，2依次入栈，存储的是数组的索引 if (command[i] != 4 && command[i] != 3) stack.push(i); } } //回滚函数 private static void rollback() { int index = stack.pop();//获取栈顶元素，即上一次执行的操作的数组索引 int cmd = command[index];//根据索引获取命令 String value = val[index];//根据索引获取命令对应的值 //上次命令为1，追加字符串，回滚则删除追加的字符串 if (cmd == 1) { int len = value.length(); str.delete(str.length() - len, str.length()); } //上次命令为2，删除字符串，回滚则追加删除的字符串 if (cmd == 2) str.append(del.pop()); } } 文章翻译 题目描述 输入： 第一行表示文章，长度不超过50000 第二行，正整数[2,50000]，字典单词 N行，每行一个单词 输出: 文章翻译种数对835672545取余 无法翻译输出0 示例输入 abcba 5 ab cb bc ba a 示例输出 2 袜子染色 题目描述 第i天穿袜子a_i和b_i，要求颜色标号相同 第一行两个整数n（袜子数量）和m（天数）均小于100,000 第二行n个整数，第i个数c_i表示第i只袜子颜色，不大于100,000 接下来m行，每行两个整数a_i和b_i，表示第i天穿的袜子编号 输出最少需要染色数 示例输入 3 2 1 2 3 1 2 2 3 示例输出 2 和猫咪玩游戏 题目描述 首先输入字符串s 一行输入一个n，表示接下来有n个操作 接下来n行，每行表示一个操作 修改：1 整数pos 一个字符c 表示将整数替换为c 提问：2 l r 求s[l...r]有多少个互不相同的字符 示例输入 abacaba 5 2 1 4 1 4 b 1 5 b 2 4 6 2 1 7 示例输出 3 1 2 "},"面试笔试/阿里3月23日笔试.html":{"url":"面试笔试/阿里3月23日笔试.html","title":"阿里3月23日笔试","keywords":"","body":"阿里3月23日笔试 第一题 输入一个整数n 1 思路 用int肯定会超，需要用到BigInteger 对于输入n，求得所有元素之和为n*2^n-1^ 然后再对10^7^+7取模即可 代码 public class Solution1 { public static void main(String[] args) { Scanner sc = new Scanner(System.in); String n = sc.next(); BigInteger in = BigInteger.valueOf(Long.parseLong(n)); BigInteger num = f(in);//种数 BigInteger x = BigInteger.valueOf(10).pow(9).add(BigInteger.valueOf(7)); System.out.println(num.mod(x)); } private static BigInteger f(BigInteger n) { return n.multiply(BigInteger.valueOf(2).pow(n.intValue()-1)); } } 第二题 输入n,m两个整数代表n行m列 下面输入n行字符串，每个字符串都包含m个字符（只含有'.','#','E','S'） 其中S代表起点，E代表终点，#代表无法通过 从起点出发，可向左，向右，向上，向下移动一步 也可按如下中心对称移动，也只算移动一步 X（i,j）→ X‘（n+1-i,m+1-j） 求从起点到终点最少需要移动几步 示例输入 4 4 #S.. E#.. #... .... 输出 4 说明 先中心对称到达（4，3），然后向上一步，向右一步，中心对称到达终点 第2题我还没做完到时间了&#x1F62D; "},"面试笔试/面试突击.html":{"url":"面试笔试/面试突击.html","title":"面试突击","keywords":"","body":"Java基础 Java基本数据类型 8种（1个字节是8个bit） 整数型： byte（1字节）-128(2^7^)~127 short（2字节）-32 768(2^15^)~32 766 int（4字节）-2 147 483 248(2^31^)~2 147 483 247 long（8字节）-2^63^~2^63^-1 浮点型： float（4字节） double（8字节） 布尔型：boolean（1字节） 字符型：char（2字节） 代码分析 int i = 3; float f1 = 3, f2 = 3.25f, f3 = 3.1f; //float f4 = 3.0;//编译报错，3.0为double类型 double d1 = 3, d2 = 3.1; System.out.println(i == f1);//true System.out.println(d1 == f1);//true System.out.println(3.25 == f2);//true 二进制可以精确表示3.25(11.01) System.out.println(f1 == 3.1);//false 二进制无法精确表示1/10,就像十进制无法精确表示1/3 System.out.println(d2 == 3.1);//true IO与NIO 包括 类File，outputStream，inputStream，writer，reader，seralizable（5类1接口） NIO三大核心内容 selector（选择器，用于监听channel），channel（通道），buffer（缓冲区） NIO与IO区别，IO面向流，NIO面向缓冲区；io阻塞，nio非阻塞 "}}