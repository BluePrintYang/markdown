## CH 3 汇编语言指令集

[TOC]

### 概述

#### 指令

#### 指令的书写格式

- 机器指令
- 符号指令

#### 指令的组成

操作码+操作数

#### 目标程序的生成

#### 指令长度

> 80X86指令长度（机器指令长度）为1～16字节

规定：多字节指令占用连续的内存单元，存放指令第一字节的内存单元地址，称为“指令地址”。

#### 指令存放

:star:小端法规则:==低位字节存放在低地址单元，高位字节存放在相邻的高地址单元==

​	例:12345H单元中有一条指令    MOV   AX,6789H

​	<img src="C:\Users\16711\AppData\Roaming\Typora\typora-user-images\image-20191026144244523.png" alt="image-20191026144244523" style="zoom:67%;" />

#### 符号指令的书写格式

| 标号： | 操作码助记符 | 空格 | 操作数助记符 | ;注释     |
| ------ | ------------ | ---- | ------------ | --------- |
| NEXT:  | ADD          |      | AX,BX        | ;AX+BX→AX |

- 标号：以字母或下划线开头,后跟字母,数字,下划线,长度≤31字符。

  又称符号地址,代表该指令的逻辑地址。可以忽略不写，但在设置为程序的转向目标时必须写出。



### 操作数

> 表示指令的操作对象。包括输入数据和输出数据

在计算机硬件中，这些数据（状态）被存放在三个区域： 

1. CPU的寄存器
2. 计算机的存储器
3. 计算机接口电路中的端口

#### 通用寄存器中的操作数

操作数的字长由操作数名称决定。例如EAX中操作数为32位,AX中16位,AH和AL为8位。具体参考上一章。

#### 段寄存器和程序指针

- 代码段寄存器CS以及指令指针IP决定了CPU将要取出的指令

- 修改CS和IP的值则可以改变CPU取出的指令，在程序设计可以实现程序控制转移，例如分支和循环

- 当操作数存放在存储器中时，数据段DS，堆栈段SS以及附加段（ES，FS和GS）用于存放CPU取出该操作数所需的段基址，偏移地址则依据相应寻址方式的地址表达式给出

#### 标志寄存器

80X86标志寄存器为32位,实际使用15位,共14个标志。 
标志分为两类:状态标志和控制标志 

- 状态标志记录了当前指令执行后的状态信息 
- 控制标志用来控制微处理器操作

状态标志

1. 进位标志C
2. 溢出标志O
3. 符号标志S
4. 奇偶标志P
5. 辅助进位标志A
6. 零标志Z

题目整理中有详细例子解析

控制标志

1. 方向标志D
2. 中断允许标志I
3. 陷阱标志T

### 寻址方式

> 通知CPU本条指令的操作数在哪儿

#### 操作数的存在方式

1. 在指令中，称为立即数    MOV AX,1234H
2. 在CPU的某个寄存器中，称为寄存器操作数   MOV DS,AX
3. 在存储器中，存储器操作数，称为存储器操作数(内存操作数)  MOV AX,DS:[2000H]
4. 在I/O端口中，I/O端口操作数  IN AL,60H

#### 寻址方式

##### 立即寻址

> 操作数直接放在指令中，紧跟在操作码的后面，与操作码一起放在代码段区域中

​	书写规定

- 立即数以数字开头，以Ａ～Ｆ开头的16进制数，必须前缀0
- 立即数的数制用后缀表示,B表示二进制数,H表示十六进制数,D或缺省为十进制数，单引号括起来的字符编译成相应的ASCII码 
- 可以用+   –   *  /  组成立即数表达式
- 程序员可以按自己的习惯书写立即数，各种合法的立即数经汇编后，一律自动转换成等值的==二进制数==，负数用补码表示

##### 寄存器寻址

> 操作数在CPU的某个寄存器中，符号指令中直接写出寄存器名称

##### 存储器操作数寻址

- 在读写内存操作数之前，CPU必须知道相关存储单元的物理地址
- 由于CPU对存储器采用分段管理, 因此指令格式中只能写出存放操作数的内存单元的“逻辑地址”
- 程序员的责任仅在于正确的书写逻辑地址表达式，然后由CPU自动运算以求出物理地址

程序员给出的逻辑地址形式:段寄存器:偏移地址

###### 偏移地址的构成

**直接地址**

> 包含在指令中

1. 段寄存器：[偏移地址]   MOV	AL, ES:[2CH] 很少使用,不知道偏移地址
2. 段寄存器：变量名         

**间接地址**

> 操作数在内存单元，该单元的段基址在段寄存器中,有效地址在间址寄存器中

1. 段寄存器：[间址寄存器]      

   物理地址=段寄存器内容×16+间址寄存器

2. 简化：[间址寄存器]              

   物理地址===约定的段寄存器内容==×16+间址寄存器

| 间址寄存器            | 约定访问的逻辑段 |              |
| --------------------- | ---------------- | ------------ |
| BP                    | 堆栈段           | 16位寻址方式 |
| ==BX，SI，DI==        | ==数据段==       | 16位寻址方式 |
| EBP，ESP              | 堆栈段           | 32位寻址方式 |
| ==EAX~EDX，ESI，EDI== | ==数据段==       | 32位寻址方式 |

**基址**

> 由两部分组成。一部分在基址寄存器中，另一部分为常量 

1. 段寄存器:[基址寄存器+位移量]
   物理地址=段寄存器内容×16+基址寄存器+位移量
2. [基址寄存器+位移量]
   物理地址===约定的段寄存器内容==×16+基址寄存器+位移量

| 基址寄存器            | 约定访问的逻辑段 |              |
| --------------------- | ---------------- | ------------ |
| BP                    | 堆栈段           | 16位寻址方式 |
| ==BX==                | ==数据段==       | 16位寻址方式 |
| EBP，ESP              | 堆栈段           | 32位寻址方式 |
| ==EAX~EDX，ESI，EDI== | ==数据段==       | 32位寻址方式 |

**变址**

1. 有比例因子：段寄存器：[比例因子*变址寄存器+位移量]

   物理地址=段寄存器×16+比例因子×变址寄存器+位移量 

2. 段寄存器：[变址寄存器+位移量]
   访问约定的逻辑段可简化为 ： 
   [变址寄存器+位移量]
   物理地址=约定的段寄存器×16+变址寄存器+位移量

| 变址寄存器        | 约定访问的逻辑段 | 适用于...           |
| ----------------- | ---------------- | ------------------- |
| SI，DI            | 数据段           | 无比例因子,16位寻址 |
| EBP               | 堆栈段           | 有比例因子,32位寻址 |
| EAX~EDX，ESI，EDI | 数据段           | 有比例因子,32位寻址 |

==比例因子只能是1、2、4、8==

==16位寻址不能使用比例因子==

**基址加变址**

存储单元的有效地址由3部分组成

1. 有比例因子的基址加变址的地址表达式为：
   段寄存器：[基址寄存器+比例因子*变址寄存器+位移量]

   访问约定逻辑段其地址表达式简化为：
       [基址寄存器+比例因子*变址寄存器+位移量]

2. 无比例因子基址加变址
   地址表达式：
       段寄存器：[基址寄存器+变址寄存器+位移量]
   访问约定逻辑段：
       [基址寄存器+变址寄存器+位移量]

基址加变址寻址是基址寻址和变址寻址的组合，要求

- 基址寄存器和变址寄存器都是16位或都是32位，否则（16位寻址和32位寻址混合使用）是非法指令
- 默认的段寄存器不一致，这样的组合虽然是合法，但容易出错

##### I/O端口操作数寻址

### 汇编语言语法

#### 概述

编辑→.ASM文件→编译→.OBJ文件→链接→.EXE .COM文件

#### 汇编源程序中的语句类型和格式

- 指示性语句：符号指令→经汇编后,其目标指令通知CPU进行什么操作

- 指令性语句：伪指令和宏指令→是非机器指令，是在汇编期间进行操作的。  

  ​					   							   为汇编程序,链接程序提供汇编链接信息

符号指令格式

| **标号：** | **操作码助记符** | **空格** | **操作数助记符（多个操作数之间用，隔开）** | **；注释** |
| ---------- | ---------------- | -------- | ------------------------------------------ | ---------- |
|            |                  |          |                                            |            |

伪指令

| **变量** | **伪指令助记符** | **空格** | **操作数项（多个操作数之间用，隔开）** | **；注释** |
| -------- | ---------------- | -------- | -------------------------------------- | ---------- |
| N1       | DB               |          | 12H,64,-1,3*3                          |            |

说明：

1. 变量名后面没有“:”
2. 不同的伪指令，操作数个数和类型不同

##### 常用伪指令

1. 字节定义伪指令 ==DB==

   变量名 ==DB== 一个或多个用逗号间隔的单字节数

   功能:通知汇编程序把DB后跟的单字节数,==依次存入从变量(如N1)开始的单元==,==负数用补码==表示,==单引号==中的字符翻译成==ASCII码==

2. 字定义伪指令 ==DW==

   :star:存放时满足小端法规则

3. 双字 ==DD==

4. 多字节

   - DF 6字节
   - DQ 8字节
   - DT 10字节

5. 等值伪指令 ==其值在后继语句中不能更改==

   符号常数 EQU 表达式
     如:   NUM   EQU   33

   功能: 定义符号常数NUM的值为33 

6. 等号伪指令 ==其值在后继语句中可以重新定义==

   符号常数=表达式
     如:  NUM = 33  

    功能:定义符号常数NUM的值为33     

##### 常用运算符

1. 算术运算符: +, -, \*, /  

2. 关系运算符:EQ(等于), NE(不等于), GT(大于),LT(小于),GE(大于或等于)

3. $运算符
       汇编程序对源程序是逐行汇编的,$运算符可以返回汇编计数器的当前值、

      $运算符紧跟在 DB、DW、DD伪指令之后,统计字符串的长度

      例如数据段有: 
                BUF   DB ’THE  QUICK  BROWN  FOX’     ;字符串长度19
                LLL   EQU    $-BUF
          汇编后  符号常数LLL的值即为19

4. SEG  计算某一逻辑段的段基址

5. OFFSET 计算逻辑段中某个变量或标号的偏移地址

6. PTR

7. [] 用方括号括起来的地址表达式是访问内存操作数常用的寻址方式，方括号的另一用途是标注数组元素的下标，下标从0开始

### 汇编语言基本指令集

说明

1. 对于双操作数
   - 源、目操作数不可同为内存操作数
   - 源、目操作数属性一致（长度相同）
   - 当目标操作数为间址、变址、基址、基+变址的内存操作数，而源操作数为单字节/双字节立即数，则目标操作数必须用PTR说明类型
2. 单操作数
   - 若操作数为间、变、基、基+变的内存操作数，则必须用PTR说明类型

#### 传送指令

##### 通用传送

数据传送

1. MOV
2. LEA 偏移地址传送
3. XCHG OPRD1,OPRD2    将OPRD1和OPRD2中数据交换
4. 查表指令 XLAT 表头变量名

#### 堆栈操作指令

> 堆栈——按照先进后出的原则组织的一段内存区域
>
> 堆栈指针SP的初值决定了堆栈的==大小==,==SP始终指向堆栈的顶部==

栈顶：栈区的低地址
栈底：栈区的高地址

- 堆栈段寄存器SS：存放堆栈段段基址
- 堆栈指针ESP(SP)：存放栈顶单元的偏移地址
- SS、ESP(SP)初值，由程序员赋值或DOS自动赋值

##### 数据进栈（以16位操作数进栈为例）

SP-2→SP

高8位→SS：[SP+1]

低8位→SS：[SP]

##### 数据出栈

SS：[SP]→目标(目标寄存器，目标单元)低8位

SS：[SP+1]→目标高8位

SP+2→SP

进栈指令

PUSH      源操作数

非直接寻址的内存操作数，必须用PTR说明属性

出栈指令

POP      目标操作数  

非直接寻址的内存操作数，必须用PTR说明属性



#### 算术运算指令

##### 加法类指令

1. ADD 影响标志位
2. ADC 带进位  影响标志位
3. INC  功能:+1   影响标志位
   - 该指令将操作数视为无符号数
   - 不影响进位标志C

##### 减法类指令

1. SUB
2. SBB 带借位
3. DEC 功能:-1 
4. ==NEG== 求补指令，将操作数按位取反后加1，再送回操作数
5. ==CMP== 不改变源目操作数，只改变标志位
   - 该指令同 SUB , 但其不保存运算结果
   - 该指令后面通常跟一条转移指令，根据标志位产生不同的程序分支

##### 乘法指令

1. MUL   SRC —— 无符号数乘法 

2. IMUL   SRC —— 带符号数乘法
         源操作数：通用寄存器、存储器（不能是立即数）
         ==目的操作数：DX, AX （隐含）==
         执行的操作：字节操作   （AH,AL）←（AL）*（SRC） 

   ​							 字操作       （DX,AX）← （AX） *（SRC）

##### 除法指令

1. DIV   SRC —— 无符号数除法

2. IDIV   SRC —— 带符号数除法

   源操作数：通用寄存器、存储器  （不能是立即数）
   ==目的操作数：DX, AX （隐含）==
   执行的操作：字节操作   (AL) ←(AX) / (SRC) —— 商 
                                             (AH)← (AX) / (SRC) —— 余数
                           字操作     (AX) ← (DX,AX) / (SRC) —— 商
                                            (DX) ← (DX,AX) / (SRC) —— 余数

##### BCD码调整指令



#### 逻辑运算指令

1. AND
2. OR
3. XOR
4. TEST 实现两个操作数的按位与运算，结果不保存，只影响标志位
5. NOT 实现操作数的按位取反运算



##### 一般移位指令

影响C标

- SAL  OPRD, CNT   ——  算术左移
- SHL  OPRD, CNT   ——  逻辑左移
- SHR  OPRD, CNT   ——  逻辑右移
- SAR  OPRD, CNT   ——  算术右移  最高位(符号位)不变

CNT：移位次数，只能是立即数或CL寄存器

##### 循环移位指令

影响C标

- ROL  OPRD, CNT   ——  循环左移
- ROR  OPRD, CNT   ——  循环右移
- RCL  OPRD, CNT   ——  带进位的循环左移
- RCR  OPRD, CNT   ——  带进位的循环右移

#### 转移和调用指令

##### 无条件转移

JMP

##### 条件转移

JZ/JE Z=1/结果相等转移   其他标志O，S，P同Z

JNZ/JNE  Z=0/结果不相等转移

##### 无符号数比大小

| **指令**       | **功能**                     | **转移条件** |
| -------------- | ---------------------------- | ------------ |
| **JC   OPRD**  | 低于/不高于等于/有借位则转移 | **C=1**      |
| **JNC   OPRD** | 不低于/高于等于/无借位则转移 | **C=0**      |
| **JNA   OPRD** | 低于或等于/不高于则转移      | **C∨Z=1**    |
| **JA   OPRD**  | 不低于或等于/高于则转移      | **C**∨Z=0    |

##### 有符号数比大小

| **指令**       | **功能**                    | **转移条件**     |
| -------------- | --------------------------- | ---------------- |
| **JL    OPRD** | **小于/不大于等于则转移**   | **S⊕O=1 且 Z=0** |
| **JGE   OPRD** | **不小于/大于或等于则转移** | **S⊕O=0 或 Z=1** |
| **JLE   OPRD** | **小于或等于/不大于则转移** | **S⊕O=1 或 Z=1** |
| **JG    OPRD** | **不小于等于/大于则转移**   | **S⊕O=0 且 Z=0** |

##### 循环控制转移指令

| **指令**                 | **功能**                       | **循环条件**   |
| ------------------------ | ------------------------------ | -------------- |
| **LOOP   OPRD**          | **计数器不为零循环**           | **CX≠0**       |
| **LOOPZ / LOOPE OPRD**   | **计数器不为零且相等时循环**   | **CX ≠0且Z=1** |
| **LOOPNZ / LOOPNE OPRD** | **计数器不为零且不相等时循环** | **CX ≠0且Z=0** |

##### 子程序调用及返回指令

CALL  <调用地址>
RET 

##### 串操作指令

80X86有6条串操作指令,它们是串传送、串比较、串搜索、串装入、串存储和I/O串操作,这里仅介绍前5条

- ==源串要放在数据段==,==目标串要放在ES附加段==
- 在16位寻址操作下,CPU自动==用SI间址访问数据段==,用==DI间址访问ES附加段==、用==CX做为串计数器==

1. 串传送：SI→DI

   - 功能：把DS:[SI]的若干元素→ ES:[DI]的若干单元
   - 基本型格式： 字节串传送	   MOVSB
     	                    字串传送           MOVSW
                             双字串传送	   MOVSD
   - 指令执行前的准备工作：
         源串的首地址/末地址→DS:SI
        目串的首地址/末地址→ES:DI
        D标志置0/置1
   - 该指令传送一个元素后，CPU自动修改SI,DI
          当D标志为0时，SI,DI增量修改
          当D标志为1时，SI,DI减量修改
   - 有重复前缀的格式          REP	MOVSB
     			                             REP	MOVSW
       			                             REP	MOVSD
     准备工作：① 同基本型格式
     	               ② 欲传送的元素个数→CX 		


   <img src="C:\Users\16711\AppData\Roaming\Typora\typora-user-images\image-20191026205904705.png" alt="image-20191026205904705" style="zoom:67%;" />

   
   <img src="C:\Users\16711\AppData\Roaming\Typora\typora-user-images\image-20191026205926577.png" alt="image-20191026205926577" style="zoom:67%;" />

2. 串装入：装入SI

   1. 基本格式
      - LODSB	;DS:[SI]的1个字节→AL,自动修改SI
      - LODSW	;DS:[SI]的2个字节→AX,自动修改SI
      - LODSD	;DS:[SI]的4个字节→EAX,自动修改SI

3. 串存储：存入DI

   1. STOSB	;AL →ES:[DI]的1个单元,自动修改DI
   2. STOSW	;AX →ES:[DI]的2个单元,自动修改DI
   3. STOSD	;EAX→ES:[DI]的4个单元,自动修改DI

   有重复前缀的格式
         REP    STOSB
         REP    STOSW
         REP    STOSD

4. 串比较：比较两串字符是否相等

   1. 基本格式

      - 字节串比较      CMPSB
      - 字串比较	      CMPSW
      - 双字比较		  CMPSD

      有重复前缀的格式1
                REPE     CMPSB   
                REPE     CMPSW 
                REPE     CMPSD 

      有重复前缀的格式2
               REPNE   CMPSB   
               REPNE   CMPSW
               REPNE   CMPSD

5. 串搜索：在ES:[DI]的目标区，搜索是否有规定的“关键字”

   1. 基本型格式
      - SCASB
      - SCASW
      - SCASD
   2. 功能：比较AL/AX/EAX=ES:[DI]? 
            若ES:[DI]=关键字，则Z置1，否则Z置0，修改DI

#### 处理机控制指令

| **名称**                      | **格式** | **功能（对标志位的影响）** |
| ----------------------------- | -------- | -------------------------- |
| **进位标志清** **0** **指令** | **CLC**  | **C = 0**                  |
| **进位标志置** **1** **指令** | **STC**  | **C = 1**                  |
| **进位标志取反**              | **CMC**  | **C= C**                   |
| **方向标志清** **0** **指令** | **CLD**  | **D = 0**                  |
| **方向标志置** **1** **指令** | **STD**  | **D = 1**                  |
| **中断标志清** **0** **指令** | **CLI**  | **I = 0**                  |
| **中断标志置** **1** **指令** | **STI**  | **I = 1**                  |

#### 其他处理指令

| **名称**                       | **格式** | **功能**                     | **状态标志位** |
| ------------------------------ | -------- | ---------------------------- | -------------- |
| **处理器等待指令**             | **WAIT** | **处理器等待**               | **不影响**     |
| **处理器交权指令（换码指令）** | **ESC**  | **处理器交权**               | **不影响**     |
| **总线封锁前缀**               | **LOCK** | **封锁总线**                 | **不影响**     |
| **处理器暂停指令**             | **HLT**  | **使处理器暂时处于停机状态** | **不影响**     |
| **空操作指令**                 | **NOP**  | **使CPU不进行任何操作**      | **不影响**     |