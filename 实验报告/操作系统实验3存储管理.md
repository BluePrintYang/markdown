#### 实验目的

理解操作系统存储管理原理

> 操作系统的发展使得系统完成了大部分的内存管理工作。对于程序员而言，这些内存管理的过程完全透明不可见。因此，程序员开发时从不关心系统如何为自己分配内存，而且永远认为系统可以分配给程序所需要的内存。在程序开发时，程序员真正需要做的就是：申请内存、使用内存、释放内存，其他一概无需过问。



#### 程序1

申请内存、使用内存以及释放一块内存 

```C
//B17040417.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>
int main(void)
{
char * str;
if ((str=(char*)malloc(10))==NULL)
{
  printf("not enough memory to allocate buffer\\n");
  exit(1);
}
strcpy(str,"hello");
printf("string is %s\n",str);
free(str);
return 0;
}
```



#### 程序2

在打开文件后，通过fstat()获得文件长度，然后通过malloc()系统调用申请响应大小的内存空间，通过read()将文件内容完全读入该内存空间，并显示出来。  

```c
//yanglonglong.c(路径: /opt/yanglonglong.c)
#include <stdio.h>
#include <sys/stat.h>
#include <unistd.h>
#include <stdlib.h>
#include <malloc.h>
#include <string.h>
#include <sys/types.h>
#include <fcntl.h>
main()
{
  int fd,len;
  void *tp;//void *则为“无类型指针”，可以指向任何数据类型
  struct stat ps;
  fd=open("/opt/yanglonglong.c",0);
  fstat(fd,&ps);
  len=ps.st_size;
  tp=malloc(len);
  read(fd,tp,len);
  printf("%s\n",tp);
  printf("size:%d bytes\n",len);
  close(fd);
}
```





#### 知识点

##### 相关函数

###### 1）内存动态分配函数 

\#include <malloc.h> 

void *malloc(size_t size) 

该函数分配指定大小size个字节的内存空间，成功时返回分配内存的指针（即所分配内存的地址）。该内存区域没有清空。 

###### 2） void free(void * addr); 

该函数释放由malloc()分配的内存，addr是要释放内存空间的起始地址，并且addr必须是被以前malloc( )调用返回的。 



##### malloc的使用方法及注意事项

使用C语言进行开发的时候,内存管理非常重要,如果内存管理不当,会导致内存泄露,程序无故死机,
在C语言中内存管理中,需要使用malloc()和free()两个函数

###### 1 为什么要使用malloc和free ?

使用malloc,free可以动态的分配内存和动态释放内存,节约应用程序的运行时,所占用的内存空间,以上也是malloc的优点。

###### 2 malloc和指针的关系?

void p= *malloc(long num)：该函数分配了num个字节,并返回了指向这块内存的指针。如果分配失败，则返回一个空指针（NULL）。
关于分配失败的原因，应该有多种，比如说空间不足就是一种。
void free(p)： 该函数是将之前用malloc分配的空间还给程序或者是操作系统，也就是释放了这块内存,让这块内存重新交给操作系统管理。
综上所述：因为malloc分配成功后返回内存的首地址，在使用中是按地址来进行调用，所以有malloc分配内存的时候，就有指针存在。

###### 3 一般什么情况下需要用到malloc ?

在程序运行的时候，可变的array,struct可以用到malloc分配内存，也可以采用分配一个连续的空间 存储一批相同类型的变量。

###### 4 malloc的用法

程序代码：

```c
char *p = NULL;
p= (char *)malloc(100 * sizeof(char)); //分配100个字符串
if (NULL == p) //检测malloc是否分配成功
{
exit (1);
}
//使用分配空间
free(p); //释放空间
p= NULL; //指针释放
```

###### 5 malloc使用注意事项

1. malloc内存空间后,需要检查是否分配成功!
2. 使用完毕后需要释放内存空间，释放后应该把指向这块内存的指针指向NULL,避免再次使用时，出现奇怪的错误现象。
3. malloc内存后，不释放会产生内存泄露，多次使用free释放会导致程序报错。
4. malloc内存时候，需要对返回的指针类型做强制转换。



##### read函数

用read函数读取数组中的元素：

```c
char buf[200];
read(0, buf, 5);
```

第一个参数说明的是从0开始读取
第二个参数是：要读取的数组buf
第三个参数是：要读5个

总结：从第0个开始读取buf中的5个元素（连续的）





##### fstat

功能：
获得文件或共享内存区的信息
头文件：

```c
#include <sys/stat.h> 
#include <unistd.h> 
#include <fcntk.h> 
```

函数原形：

```c
int stat(const char *file_name,struct stat *buf);
```

参数：
file_name          文件名
buf                     stat结构
返回值：
成功返回0，出错返回-1
对于普通文件stat结构可以获得12个以上的成员信息，然而当fd指代一个共享内存区对象时，只有四个成员含有信息。

```c
struct stat{
	mode_t st_mode;
	uid_t st_uid;
	gid_t st_gid;
	off_t st_size;
};
```





##### exit()函数: 

所在头文件：==stdlib.h==
功 能: 关闭所有文件，终止正在执行的进程。
exit(1)表示异常退出.这个1是返回给操作系统的。
exit(x)（x不为0）都表示异常退出
exit(0)表示正常退出
exit()的参数会被传递给一些操作系统，包括UNIX,Linux,和MS DOS，以供其他程序使用。
==stdlib.h==: void exit(int status);
参 数 : status //程序退出的返回值.





##### exit函数和return函数的主要区别：

   1）exit用于在程序运行的过程中随时结束程序，exit的参数是返回给OS的。main函数结束时也会隐式地调用exit函数。exit函数运行时首先会执行由atexit()函数登记的函数，然后会做一些自身的清理工作，同时刷新所有输出流、关闭所有打开的流并且关闭通过标准I/O函数tmpfile()创建的临时文件。exit是结束一个进程，它将删除进程使用的内存空间，同时把错误信息返回父进程,而return是返回函数值并退出函数。通常情况：

- exit(0)表示程序正常,

-  exit(1)和exit(-1)表示程序异常退出，exit(2)表示表示系统找不到指定的文件。

  在整个程序中，只要调用exit就结束（当前进程或者在main时候为整个程序）。


   2）return是语言级别的，它表示了调用堆栈的返回；return( )是当前函数返回，当然如果是在主函数main, 自然也就结束当前进程了，如果不是，那就是退回上一层调用。在多个进程时。如果有时要检测上个进程是否正常退出。就要用到上个进程的返回值，依次类推。而exit是系统调用级别的，它表示了一个进程的结束。


   3）exit函数是退出应用程序，并将应用程序的一个状态返回给OS，这个状态标识了应用程序的一些运行信息。


   4）和机器和操作系统有关的一般是： 0为正常退出，非0为非正常退出；

 

##### 进程环境与进程控制

​		exit(int n)其实就是直接退出程序，因为默认的标准程序入口为 int main(int argc, char** argv)，返回值是int型的。一般在shell下面，运行一个程序，然后使用命令echo $?就能得到该程序的返回值，也就是退出值，在main()里面，你可以用return n，也能够直接用exit(n)来做。unix默认的正确退出是返回0，错误返回非0。

理论上exit可以返回小于256的任何整数。返回的不同数值主要是给调用者作不同处理的。

单独的进程是返回给操作系统的。如果是多进程，是返回给父进程的。父进程里面调用waitpid()等函数得到子进程退出的状态，以便作不同处理。根据相应的返回值来让调用者作出相应的处理.总的说来，exit（）就是当前进程把控制权返回给调用该程序的程序,括号里的是返回值,告诉调用程序该程序的运行状态。

 

##### 1） 进程的开始：

C程序是从main函数开始执行, 原型如下:int main(int argc, char *argv[]);通常main的返回值是int型, 正确返回0。如果main的返回值为void, 某些编译器会给出警告, 此时main的返回值通常是0。

 

##### 2）进程终止：

C程序的终止分为两种: 正常终止和异常终止。正常终止分为: return, exit, _exit, _Exit, pthreade_exit。异常中指分为: abort, SIGNAL, 线程响应取消。
   主要说一下正常终止的前4种, 即exit系列函数.

```c
#include <stdlib.h>   
void exit(int status);
void _Exit(int status);
```

 

```c
#include <unistd.h>   
void _exit(int status);
```

以上3个函数的区别是:exit()(或return 0)会调用终止处理程序和用户空间的标准I/O清理程序(如fclose), _exit和_ Exit不调用而直接由内核接管进行清理。因此, ==在main函数中exit(0)等价于return 0==.

 

##### 3） atexit终止处理程序：

ISO C规定, 一个进程最多可登记32个终止处理函数, 这些函数由exit按登记相反的顺序自动调用。如果同一函数登记多次, 也会被调用多次。
   原型如下:

```c
#include <stdlib.h>

int atexit(void (*func)(void));
```

其中参数是一个函数指针, 指向终止处理函数, 该函数无参无返回值。atexit函数本身成功调用后返回0。

以下面的程序为例:

```c
#include <stdlib.h>

static void myexit1()
{
    printf("first exit handler\n");
}

 
static void myexit2()
{
    printf("second exit handler\n");
}
 

int main()
{
    atexit(my_exit2)；
  atexit(my_exit1)； 

atexit(my_exit1)；
printf("main is done\n");
return 0;
}
```


运行结果:

```
$ ./a.out
main is done
first exit handler
first exit handler
second exit handler
```

注意上面的结果，可以发现这些函数由exit按登记相反的顺序自动调用（先myexit1后myexit2）。如果同一函数登记多次, 也会被调用多次（如这里的myexit1）。而这些处理函数都是在程序退出的时候利用atexit函数调用了这些处理函数。但是如果用_exit()退出程序，则它不关闭任何文件，不清除任何缓冲器、也不调用任何终止函数！

