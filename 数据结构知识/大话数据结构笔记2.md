# 大话数据结构笔记（二）

### 数据结构与算法的关系

> 就像梁山伯与祝英台，罗密欧与朱丽叶。不可只谈数据结构不谈算法。

### 两种算法的比较

> 求1+2+3+ ... +100

```c
int i, sum = 0, n = 100;
for( i = 1; i <= n; i++)
{
    sum = sum +i;
}
printf(" %d ", sum);
```
需要循环100次:sweat:

```c
//高斯的方法
int i, sum = 0, n = 100;
sum = (1 + n)*n/2;
printf("%d",sum);
```
求等差数列的算法，不需要循环:+1:

### 算法定义

> 算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作

### 算法特性

- 输入：有零个或多个输入
- 输出：至少一个输出
- 有穷性：总能在有限步后终止，且每步在可接受时间内完成
- 确定性：每一步有确定的含义，无二义性
- 可行性：每一步都可行

### 算法设计的要求

- 正确性：没有语法错误，反映问题需求，能得到正确答案，非法输入也有说明
- 可读性：便于阅读、理解和交流
- 健壮性：输入数据不合法时也也能做出相关处理，而不是产生异常或莫名其妙的结果

### 算法效率的度量方法

- 事后统计方法：通过设计好的测试程序和数据，比较运行时间
  - 缺陷
    1. 需要编写测试程序，费时费力
    2. 受环境因素影响，机器运行时环境难以保存相同
    3. 算法测试数据设计困难
- 事前分析估算方法：程序编制前，依据统计方法对算法进行估算



> 算法运行时间取决于

1. 算法采用的策略，方法   :arrow_right:  算法好坏的根本
2. 编译产生的代码质量​ ​ :arrow_right:  需要软件来支持
3. 问题的输入规模
4. 机器执行指令的速度​ ​ :arrow_right:  看硬件性能

> 一个程序的运行时间，依赖于算法的好坏和问题的输入规模。
>
> 问题的输入规模即输入量的多少

### 函数的渐进增长

> 给定两个函数f(n)和g(n)，如果存在一个整数N，使得对于所有的n > N，f(n)总是比g(n)大，那么f(n)的渐进增长快于g(n)

假设算法A和B的输入规模相同，A要做2n+3次操作，B要进行3n+1次操作

| 次数  | 算法A(2n+3) | 算法A'(2n) | 算法B(3n+1) | 算法B'(3n) |
| :---: | :---------: | :--------: | :---------: | :--------: |
|  n=1  |      5      |     2      |      4      |     3      |
|  n=2  |      7      |     4      |      7      |     6      |
|  n=3  |      9      |     6      |     10      |     9      |
| n=10  |     23      |     20     |     31      |     30     |
| n=100 |     203     |    200     |     301     |    300     |

n=1时，算法A不如算法B，n>2时，算法A就开始优于算法B了

**我们可以忽略加法常数**

同理

**最高次项相乘的常数并不重要**

**最高次项的指数大的，函数随着n的增长，结果也会变得增长特别快**

判断算法的效率时，更应该关注最高阶项的阶数

### 算法的时间复杂度

#### 时间复杂度定义

> 语句执行次数T(n)是关于问题规模n的函数。算法的时间复杂度记作：T(n)=O(f(n))
>
> 它表示随问题规模的增大，算法执行时间的增长率和f(n)的增长率相同

#### 推导大O阶方法

1. 用常数1取代运行时间中的所有加法常数
2. 在修改后的运行次数函数中，只保留最高阶项
3. 如果最高阶项存在且不是1，去除与这个项相乘的常数

得到的结果就是大O阶

#### 常见的时间复杂度

$$
O(1)<O(logn)<O(n)<O(nlogn)<O(n^2)<O(n^3)<O(2^n)<O(n!)<O(n^n)
$$

#### 最坏情况和评价情况

> 平均运行时间是所有情况中最有意义的

> 一般没有特殊说明，都指最坏复杂度

#### 算法空间复杂度







