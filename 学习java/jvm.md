## JVM

> 可运行Java代码的假想计算机

包括一套字节码指令集，一组寄存器，一个栈，一个垃圾回收，堆和一个存储方法域

JVM运行在操作系统之上，与硬件没有直接的交互



Java跨平台的原因：

​	①Java源文件→编译器→字节码文件   

​	②字节码文件→JVM→机器码

每一种平台的解释器是不同的但是实现的虚拟机是相同的





### JVM内存区域

- 线程私有
  - 程序计数器PC
  - 虚拟机栈VMStack
  - 本地方法栈
- 线程共享
  - 方法区（永久代）
  - 类实例区（Java堆）
- 直接内存





#### 程序计数器（线程私有）

当前线程所执行的字节码的行号指示器

在虚拟机中唯一一个没有规定任何OutOfMemoryError情况的区域



#### 虚拟机栈（线程私有）

描述Java方法执行的内存模型

每个方法在执行的同时会创建出一个**栈帧**，用于存储局部变量表、操作数栈、动态链接、方法出口等





#### 本地方法区（线程私有）

本地方法栈为Native方法服务



#### 堆（Heap-线程共享）-运行时数据区

创建的对象和数组都保存在Java堆内存中，也是垃圾收集器进行垃圾收集最重要的内存区域

可细分为新生代和老年代



#### 方法区/永久区

存储被JVM加载的类信息、常量、静态变量、即时编译器编译后的代码

包括**运行时常量池**



### 垃圾回收与算法









### Java四种引用类型

#### 强引用



#### 软引用



#### 弱引用



#### 虚引用







### Java IO/NIO

IO面向流，NIO面向缓冲区







### JVM类加载器

分为5个部分：加载，验证，准备，解析，初始化

#### 加载

在内存区中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的入口

#### 验证

确保class文件的字节流中包含的信息是否符合当前虚拟机的要求

#### 准备

在方法区中分配这些变量所使用的内存空间

```Java
public static int v = 8080;//变量v在准备阶段后的初始值为0而不是8080，赋值是在程序编译后，存放于类构造器<client>中
public static final int v = 8080;//在编译阶段会为v生成ConstantValue属性，准备阶段根据ConstantValue属性将v赋值为8080
```



#### 解析

虚拟机将常量池中的符号引用替换为直接引用的过程

符号引用：

1. CONSTANT_Class_info
2. CONSTANT_Field_info
3. CONSTANT_Method_info



#### 符号引用



#### 直接引用



#### 初始化

开始真正执行类中定义的Java程序代码



#### 类构造器<client>

初始化阶段执行类构造器<client>方法的过程

如果一个类中没有静态变量赋值，也没有静态语句块，那么编译器可以不为这个类生成<client>()方法





#### 类加载器

启动类加载器



扩展类加载器



应用程序类加载器



